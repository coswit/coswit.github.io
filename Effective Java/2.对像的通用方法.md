### equals约定

覆写equals的时机：当类有自己的逻辑相等(logical equality)规则。

对于基本数据类型，==和equals都是比较值。对于对像则比较是否指向同一对像，String特殊，不是通过new建的则是比较内容的，==和equals相同；new则转为对像比较。

覆写equals遵寻的约定：

- 自反性Reflexive：对于任意非空引用值x，x.equals(x)必须返回true。
- 对称性Symmetric：对于任意非空引用值x和y，x.equals(y)必须返回true，当且仅当y.equals(x)返回true。
- 传递性Transitive：对于任意非空引用值x，y，z，如果x.equals(y)返回true而且y.equals(z)也返回true，那么x.equals(z)必须返回true。
- 一致性Consistent：对于任意非空引用值x和y，只要equals方法中使用的信息没有被修改，那么不管多少次调用x.equals(y)都必须一致性地返回true或者false。
- 对于任意非空引用值x，x.equals(null)必须返回false。

#### 对称性

```java
public final class CaseInsensitiveString {
    private final String s;
    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    } 
    // Broken - violates symmetry!
    @Override 
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        if (o instanceof String) // One-way interoperability!
            return s.equalsIgnoreCase((String) o);
        return false;
    }
}
```

上述代码，违反了对称性，`cis.equals(s)`返回了true，`s.equals(cis)`返回false

```java
CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish";

List<CaseInsensitiveString> list = new ArrayList<>();
list.add(cis);
```

一旦违反了equals约定，将不知道别的对象在面对你的对象时会产生什么行为，将一个大小写不敏感的字符串放入一个集合里，不能确定会返回什么结果。

修改为：

```java
@Override 
public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```

#### 传递性

```java
public class Point {
    private final int x;
    private final int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    } 
    @Override 
    public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;
        Point p = (Point)o;
        return p.x == x && p.y == y;
    } 
}

public class ColorPoint extends Point {
    private final Color color;
    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    } 
  
    // Broken - violates symmetry!
    @Override 
    public boolean equals(Object o) {
      if (!(o instanceof ColorPoint))
          return false;
      return super.equals(o) && ((ColorPoint) o).color == color;
    }
}
```

p.equals(cp)返回true，而cp.equals(p)却返回false

```java
Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED);
```

下面的方式虽然保证了对称性，但却牺牲了传递性，p1.equals(p2)和p2.equals(p3)都返回了true，但p1.equals(p3)却返回了false：

```java
// Broken - violates transitivity!
@Override 
public boolean equals(Object o) {
    if (!(o instanceof Point))
        return false;
// If o is a normal Point, do a color-blind comparison
    if (!(o instanceof ColorPoint))
        return o.equals(this);
// o is a ColorPoint; do a full comparison
    return super.equals(o) && ((ColorPoint) o).color == color;
}

ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
```

这是面向对象语言中关于等价关系的一个基本问题。我们无法在扩展一个类的同时，既增加一个值组件，又要保留equals约定，除非我们放弃面向对象的抽象带来的好处。**There is no way to extend an instantiable class and add a value component while preserving the equals contract**, unless you’re willing to forgo the benefits of object-oriented abstraction.



通过使用getClass测试替代instanceof，但却无法实现想要的功能，同时也违反了里氏替换原则，

```java
// Broken - violates Liskov substitution principle
@Override 
public boolean equals(Object o) {
    if (o == null || o.getClass() != getClass())
        return false;
    Point p = (Point) o;
    return p.x == x && p.y == y;
}
```





```java
// Initialize unitCircle to contain all Points on the unit
circleprivate static final Set<Point> unitCircle = Set.of(
                                new Point( 1, 0), new Point( 0, 1),
                                new Point(-1, 0), new Point( 0, -1));
public static boolean onUnitCircle(Point p) {
    return unitCircle.contains(p);
}
```





```java
public class CounterPoint extends Point {
    private static final AtomicInteger counter = new AtomicInteger();
    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    } 
    public static int numberCreated() { 
        return counter.get(); 
    }
}
```





```java
// Adds a value component without violating the equals
contract
public class ColorPoint {
private final Point point;
private final Color color;
public ColorPoint(int x, int y, Color color) {
point = new Point(x, y);
this.color = Objects.requireNonNull(color);
} /
**
* Returns the point-view of this color point.
*/
public Point asPoint() {
return point;
}@Override public boolean equals(Object o) {
if (!(o instanceof ColorPoint))
return false;
ColorPoint cp = (ColorPoint) o;
return cp.point.equals(point) && cp.color.equals(color);
} ..
. // Remainder omitted
}
```

