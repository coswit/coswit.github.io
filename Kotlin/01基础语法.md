## 类型

### Variables

val：不可变类型

```kotlin
val answer = 42
val answer: Int = 42
val name = if(args.size>0) args[0] else "Kotlin"
```

var:可变类型

```kotlin
var language = arrayListOf("java")
```

### 集合

```kotlin
val  set = hashSetOf(1,7,53)
val strings = listOf("first","second","third")
val list = arrayListOf(1,7,54)
val map = hashMapOf(1 to "one",7 to "seven")
val numbers = setOf(1,15,5)
```

### 数组

```kotlin
 val array = IntArray(3) //长度为3的一维数组
 val array2 = Array(3) { it * 2 } //[0,2,4]
 val array3 = emptyArray<Int>() //空数组
```

## 类

在java中的类：
```java
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}    
```

转变为Kotlin的类，在Kotlin中pulic是默认的，可以省略：

```kotlin
class Person(val name: String)
```

### 枚举类

```kotlin
enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0);

    fun rgb() = (r * 256 + g) * 256 + b
}
```

## 流程控制

### when

```kotlin
fun getMnemonic(color: Color) = when (color) {
    Color.RED -> "Richard"
    // 可以在一个分支上合并多个选项
    Color.ORANGE，Color.YELLOW -> "warm"
}
 println(getMnemonic(Color.YELLOW))	
```

不同于Java的Switch，when允许使用任何对像：

```kotlin
fun mix(c1: Color, c2: Color) =
        when (setOf(c1, c2)) {
            setOf(Color.RED, Color.YELLOW) -> Color.ORANGE
            setOf(Color.YELLOW,Color.BLUE) -> Color.BLUE
            setOf(Color.VIOLET,Color.BLUE) -> Color.INDIGO
            else -> throw Exception("Dirty Color")
        }
```

可以进一步简化为不带参数， 不需要创建新的对像：

```kotlin
fun mixOptimized(c1: Color, c2: Color) =
        when {
            (c1 == RED && c2 == YELLOW) || 
                    (c1 == YELLOW && c2 == RED) -> ORANGE
            else -> throw Exception("Dirty Color")
        }
```

可以代替if使用：

```kotlin
// 类定义
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

// 使用
fun eval(e: Expr): Int =
        when (e) {
            is Num -> e.value
            is Sum -> eval(e.right) + eval(e.left)
            else -> throw IllegalArgumentException("unknown expression")
        }
```

### while、for

```kotlin
// map集合
val binaryReps = TreeMap<Char,String>()

// 存放
for (c in 'A'..'F') {
    val binary = Integer.toBinaryString(c.toInt())
    binaryReps[c] = binary
}

// 迭代取出
for ((letter, binary) in binaryReps) {
    println("$letter =$binary")
}
```

list类集合

```kotlin
val list = listOf("10", "11", "1001")
for ((index, element) in list.withIndex()) {    
    println("$index: $element")
}
```

迭代步长：

```kotlin
// 正常迭代
for (i in 1..100){
}
// 或者
for (x in 0 until size)

// 步长迭代，步长为2的递减
for (i in 100 downTo 1 step 2){
    print(fizzBuzz(i))
}
```

使用`in`来检查集合和集合中的成员：

```kotlin
// 检查字母
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'

// 检查集合
printlin("kotlin" in setOf("Java","Scala"))
```

在when中使用in：

```kotlin
fun recognize(c:Char) = when(c){
    in '0'..'9' -> "it's a digit"
    in 'a'..'z',in 'A'..'Z' -> "it's a letter"
    else -> "I don't know.."
}
```

## 函数

### 默认参数、函数扩展、属性扩展

可以定义带有默认参数的函数：

```kotlin
fun <T> joinToString(collection: Collection<T>,
                     separator:String=",",
                     prefix:String=" ",
                     postfix:String=" "):String{
}
```

在Kotlin中可以通过顶层函数来代代替Java中类似工具类的静态函数，这些函数直接放到代码文件的顶层，不用从属于任何类：

```kotlin
package strings
 
// 可以通过注解指定类名
@file:JvmName("StringFunctions") 

fun joinToString( /* ... */ ): String { /* ... */ }
```

扩展函数，对已有函数进行扩展，如果扩展函数定义了和已有函数相同的名称，则不会覆写。扩展函数相当于静态扩展：

```kotlin
fun String.lastChar():Char = get(length -1)
```

扩展属性：

```kotlin
// 在原有基础上增加了get和set lastChar
var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }
```

### `Infix`中缀调用

下面代面观中的to不是内置结构，而是一种手殊的中缀函数调用：

```kotlin
val map = mapOf(1.to("one"), 7 to "seven", 53 to "fifty-three")
```

其函数声明：

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

可以直接调用`Pair`内容来初始化两个变量，这个功能称为解构声明 **destructuring declaration**

### 比较

在Kotlin中`==`是调用equals进行值比较的：

```kotlin
class Customer(val name: String, val postalCode: Int)

val customer1 = Customer("Alice", 342562)
val customer2 = Customer("Alice", 342562)
println(customer1 == customer2)       // false，需要重写equals
```

重写后的：

```kotlin
class Client(val name: String, val postalCode: Int) {

    override fun equals(other: Any?): Boolean {
        if (other == null || other !is Client)
            return false
        return name == other.name &&
                postalCode == other.postalCode
    }

    override fun toString(): String {
        return "Client(name=$name,postalCode=$postalCode"
    }

    override fun hashCode(): Int {
        return name.hashCode() * 31 + postalCode
    }

    fun copy(name: String = this.name,
             postalCode: Int = this.postalCode) = Client(name, postalCode)
}
```

