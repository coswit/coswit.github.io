## 类修饰符

在Kotlin中类和方法`默认都是final`的，如果子类中需要重写该方法需要使用open；而Java的方法默认是open的。

在Java中默认修饰符是包可见，在Kotlin中默认是`public`,增加`internal`表示模块内部可见(“visible inside a module”)。此外Kotlin允许在顶层函数中使用`private`，表示仅在当前文件中可见

| Modifier         | Class member          | Top-level declaration |
| :--------------- | --------------------- | --------------------- |
| public (default) | Visible everywhere    | Visible everywhere    |
| internal         | Visible in a module   | Visible in a module   |
| protected        | Visible in subclasses | --                    |
| private          | Visible in a class    | Visible in a file     |

```kotlin
internal open class TalkacitiveButton : Focusable{
    private fun yell() = println("Hey!")

    protected fun whisper() = println("Let's talk!")
}

fun TalkacitiveButton.giveSpeech(){
    //错误，私有不可访问
    yell()   
    //错误protected 不能访问
    whisper()
}
```
Kotlin禁止`public`函数去引用低可见性(less-visible type)函数,通用规则：所有使用到的类型，基本参数、类相关参数、函数标识，必须与类或方法自身相一致(requires all types used in the list of base types and type parameters of a class, or the signature of a method, to be as visible as the class or method itself)。上述例子中，可以将函数改为`internal`或将类改为`public`。

`protected`在Java和Kotlin中是不一样的：在Java中，同一包下的其他成员可以访问该成员（you can access a `protected` member from the same package）；而Kotlin中不允许，protected成员只在自身类和子类中可见，同时类的扩展函数不能访问private和protected成员。

Kotlin不同于Java，外部类不能访问内部类的`private`成员。

> Kotlin中的`public、protected、private`修饰符在编译成Java字节码时会被保留，不同的在于`private`，Java中类是不可以使用`private`修饰的，所以在Kotlin中会该类会被编译为protected。
>
> `Inernal`在Kotlin中表示模块可见，一个模块通常会由多个包组成，不同模块可能包含来自同一个包的声明。类的Internal成员名称会被破坏（names of internal members of a class are mangled）

## 特殊类

###  内部类

```kotlin
import java.io.Serializable

interface State: Serializable

interface View {
    fun getCurrentState(): State
    fun restoreState(state: State) {}
}
```
在Java中内部类隐式地持有外部类的引用，如果内部类进行序列化时，会报错，如：

```java
public class Button implements View {
    @NotNull
    @Override
    public State getCurrentState() {
        return new ButtonState();
    }

    @Override
    public void restoreState(@NotNull State state) {}

    public class ButtonState implements State{}
}
```
会出现 `java.io.NotSerializable-Exception`: 虽然序列化的是 `ButtonState`，但在Java中声明内部类时，内部类持有了外部类的引用，内部类可以直接使用外部类的引用，外部Button的序列化破坏了内部类的序列化，需要将`ButtonState`声明为`static`。

而在Kotlin中则不会，默认内部类是`static`：

```kotlin
class Button : View {
    override fun getCurrentState(): State {
        return ButtonState();
    }

    override fun restoreState(state: State) {
    }

    class ButtonState : State {}
}
```
如果想要将其变成内部类持有外部引用时，需要使用`inner`来声明，同时引用要通过`this@Outer`来使用。

```kotlin
class Outer {
    inner class Inner {
        fun getOuterReference(): Outer = this@Outer
    }
}
```

###  密封类（Sealed classes）

密封类是一种受限继承结构的类，直接子类必须嵌套在父类中

```kotlin
interface Expr

class Num(val value: Int) :Expr

class Sum(val left:Int,val right:Expr) :Expr

fun eval(e:Expr):Int = 
        when(e){
            is Num -> e.value
            is Sum -> eval(e.right)
            else -> 
                    throw IllegalArgumentException("unknown expression")
        }
```
在上述代码中，如果不使用密封类，需要添加不支持的异常情况。如果使用了密封类则不需要
```kotlin
sealed class Expr {

    class Num(val value: Int) : Expr()

    class Sum(val left: Int, val right: Expr) : Expr()
}


fun eval(e: Expr): Int =
        when (e) {
            is Expr.Num -> e.value
            is Expr.Sum -> eval(e.right)
        }
```
<img src="./Kotlin/images/06.png" style="zoom:50%;" />

### 数据类(data classes)

```kotlin
data class Customer(val name: String, val postalCode: Int)
```

 为了方便数据类的使用，通常需要重写`toString`, `equals`，`hascode`方法。

### 类委托(class delegation)

Class delegation: using the “by” keyword

Kotlin中默认将类视为final，保证只有设计为可扩展的类才可以被继承。但是，经常会碰到类虽然没有被设计为可扩展的，但是需要向其增加一些其他行为，常见的解决方法是通过**装饰器模式**来实现。这种模式的本质是创建一个新类，实现原始类一样的接口，在装饰类中将原来的类实例作为字段保存，装饰类中通过转发到原始类的实例上就可以实现。如：

```kotlin
class DelegatingCollection<T> : Collection<T> {
    private val innerList = arrayListOf<T>()

    override val size: Int
        get() = innerList.size

    override fun contains(element: T): Boolean = innerList.contains(element)

    override fun containsAll(elements: Collection<T>): Boolean = innerList.containsAll(elements)

    override fun isEmpty(): Boolean = innerList.isEmpty()

    override fun iterator(): Iterator<T> = innerList.iterator()
}
```

在Kotlin中可以通过委托来简化这一操作，编译器会帮你自动生成：

```kotlin
class DelegatingCollection<T>(
        innerList: Collection<T> = ArrayList<T>()
) : Collection<T> by innerList {}
```

对于需要修改的行为可以通过复写相应的方法来实现：

```kotlin
class CountingSet<T>(
        val innerSet: MutableCollection<T> = HashSet()
) : MutableCollection<T> by innerSet {
    var objectsAdded = 0

    override fun add(element: T): Boolean {
        objectsAdded++
        return innerSet.add(element)
    }

    override fun addAll(elements: Collection<T>): Boolean {
        objectsAdded += elements.size
        return innerSet.addAll(elements)
    }
}

// 使用
fun main(args: Array<String>) {
    val cset = CountingSet<Int>()
    cset.addAll(listOf(1, 1, 2))
    println("${cset.objectsAdded} objects were added ,${cset.size} remain")
}
//3 objects were added ,2 remain
```

### object类

`object`主要用于下面几种场景：

- 定义单例的一种方式

- 定义伴生对象：`Companion objects` can contain **factory methods** and other methods that are related to this class but don’t require a class instance to be called. Their members can be accessed via class name.
- 匿名内部类使用：`Object` expression is used instead of Java’s anonymous inner class.

#### 单例定义

```kotlin
object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
        for (person in allEmployees) {}
    }
}

// 使用
 Payroll.calculateSalary()
```

####  伴生对象(Companion objects)

Kotlin中类不能拥有静态成员，在Kotlin没有static字段。使用object和包级别的顶层函数来替代，但是顶层函数无法访问类的私有成员。（Private members can’t be used in top-level functions outside of the class.）如图：

<img src="http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/05.png" alt="img" style="zoom:40%;" />

可以通过伴生对象实现通过类名来直接访问方法，类似于Java中的静态方法。

```kotlin
class A{
    companion object {
        fun bar(){
            println("Companion object called")
        }
    }
}
// 调用
>>> A.bar()
```
伴生对像可以访问类中的所有private成员，包含private构造方法。伴生对像的这一特性会很方便地实现工厂模式，将主构造方法标记为private：

```kotlin
class User private constructor(val nickname: String) {
    companion object {
        fun newSubscribeingUser(email: String) =
                User(email.substringBefore('@'))

        fun newFacebookUser(accountId: Int) =
                User(getFacebookName(accountId))
    }
}

// 调用
val subscribingUser = User.newSubscribeingUser("bob@gmail.com")
val faceBookUser = User.newFacebookUser(4)
println(subscribingUser.nickname)
```

伴生对象也可作为作为普通对象来使用：

```kotlin
interface JSONSFactory<T> {
    fun fromJson(jsonText: String): T
}

class Person(val name: String) {
    // 实现接口
    companion object : JSONSFactory<Person> {
        override fun fromJson(jsonText: String): Person = Person(jsonText)
    }
}

fun <T> loadFromJson(factory: JSONSFactory<T>, json: String): T {
    return factory.fromJson(json)
}

// 使用
fun main(args: Array<String>) {
    val json = loadFromJson(Person, "json数据")
    println(json.name)
}
```
在Java中通过Companion引用来访问：

```java
/* Java */
 Person.Companion.fromJSON("...");
```

如果想要object中的成员是静态的可以添加`@JvmStatic`和 `@JvmField`

```kotlin
class Company {
    object Employee {
        @JvmStatic
        var title = "boss"

        @JvmField
        var person: Person = Person("Jame")
    }
}
```


伴生对象可以进行扩展函数的声明：


```kotlin
class Person(val fistname:String,val lastName:String){
    companion object {}
}
//声明一个扩展函数
fun Person.Companion.fromJSON(json:String):Person{}
//调用
val p = Person.fromJSON("json")
```

#### 匿名内部类对像


在java中：

```java
 public void countClicks(Window window){
         int clickCount =0;
        window.addMouseListener(new MouseAdapter() {
            int result = clickCount+1;
        });
    }
```

不同于Java在匿名内部类中不可访问非final变量，Kotlin可以修改值：

```kotlin
fun countClicks(window: Window){
    var clickCount = 0

    window.addMouseListener(object :MouseAdapter(){
        override fun mouseClicked(e: java.awt.event.MouseEvent?) {
           clickCount++
        }
    })
}
```

## 构造方法、属性

Kotlin中区分了**主构造方法( primary constructor)** 和**从构造方法(secondary constructor)**，主构造方法声明在类体外部(outside of the class body)，而从构造方法在内部( declared in the class body)

###  构造方法

```kotlin
// 带一个参数的主构造方法
class User constructor(nickname:String){
    val nickname:String
    
	//初始化语句块
    init {
        this.nickname = nickname
    }
}
```

可以去掉constructor，简化为

```kotlin
class User constructor(_nickname:String){
    val nickname = _nickname
}
```

可以进一步加val来简化为类中的属性定义：

```kotlin
// 带一个参数的主构造方法
class User(val nickname:String)
```

子类对父类的初始化：
```kotlin
open class User(val nickName: String){}

class TwitterUser(nickName:String):User(nickName){}
```
如果没有声明构造方法，会自动生成不带任何参数的默认构造方法，即使父类没有声明任何构造参数，子类也要显式调用：
```kotlin 
open class Button

class RidoButton:Button()
```
可以将构造方法私有，使外部代码不能访问：

```kotlin
class Secretive private constructor(){}
```

从构造体（Secondary constructors）：

```kotlin
open class View {
    constructor(ctx: Context) {}
    constructor(ctx: Context, attr: Attributes) {}
}
```
### 属性

#### 接口中的属性声明

在Kotlin中接口可以声明属性：

```kotlin
interface User {
    val nickname: String
}
```

接口本身并包含任何值，没有表明这个属性值应该存储为什么方式，只有实现这个接口的类去声明。

```kotlin
//自定义getter
class PrivateUser(override val nickname: String) : User

class SubscribingUser(val email: String) : User {
    override val nickname: String
        get() = email.substringBefore('@')
}

//使用函数对属性进行初始化
class FacebookUser(val accountId:Int):User{
    override val nickname: String
        get() = getFacebookName(accountId)

    private fun getFacebookName(accountId: Int): String {
        return ""
    }
}
```
#### backing field

在 Kotlin 中，**backing field** 是一个编译器自动生成的私有字段，用于在自定义 `getter/setter` 中存储属性的实际值。通过get和set访问 backing field ：

```kotlin
class User(val name: String) {
    var address: String = "unspecified"
        set(value: String) {
            println("""Address was changed for $name:
            "$field" -> "$value".""".trimIndent())
            field = value
        }
}

 val user = User("Alice")
 user.address = "Beijing 46,10001 HD"
    
//Address was changed for Alice:
//"unspecified" -> "Beijing 46,10001 HD".    
```

#### 修改属性的默认可见性

```kotlin
class LengthCounter {
    var counter: Int = 0
        private set //不能在类外部修改这个属性

    fun addWord(word: String) {
        counter += word.length
    }
}

val lengthCounter = LengthCounter()
lengthCounter.addWord("Hi!")
println(lengthCounter.counter)
```

