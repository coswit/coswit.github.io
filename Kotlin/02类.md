## 类修饰符

在Kotlin中类和方法`默认都是final`的，如果子类中需要重写该方法需要使用open；而Java的方法默认是open的。

在Java中默认修饰符是包可见，在Kotlin中默认是`public`,增加`internal`表示模块内部可见(“visible inside a module”)。此外Kotlin允许在顶层函数中使用`private`，表示仅在当前文件中可见

| Modifier         | Class member          | Top-level declaration |
| :--------------- | --------------------- | --------------------- |
| public (default) | Visible everywhere    | Visible everywhere    |
| internal         | Visible in a module   | Visible in a module   |
| protected        | Visible in subclasses | --                    |
| private          | Visible in a class    | Visible in a file     |

```kotlin
internal open class TalkacitiveButton : Focusable{
    private fun yell() = println("Hey!")

    protected fun whisper() = println("Let's talk!")
}

fun TalkacitiveButton.giveSpeech(){
    //错误，私有不可访问
    yell()   
    //错误protected 不能访问
    whisper()
}
```
Kotlin禁止`public`函数去引用低可见性(less-visible type)函数,通用规则：所有使用到的类型，基本参数、类相关参数、函数标识，必须与类或方法自身相一致(requires all types used in the list of base types and type parameters of a class, or the signature of a method, to be as visible as the class or method itself)。上述例子中，可以将函数改为`internal`或将类改为`public`。

`protected`在Java和Kotlin中是不一样的：在Java中，同一包下的其他成员可以访问该成员（you can access a `protected` member from the same package）；而Kotlin中不允许，protected成员只在自身类和子类中可见，同时类的扩展函数不能访问private和protected成员。

Kotlin不同于Java，外部类不能访问内部类的`private`成员。



> Kotlin中的public、protected、private修饰符在编译成Java字节码时会被保留，不同的在于private，Java中类是不可以使用private修饰的，所以在Kotlin中会该类会被编译为protected。
>
> Inernal在Kotlin中表示模块可见，一个模块通常会由多个包组成，不同模块可能包含来自同一个包的声明。类的Internal成员名称会被破坏（names of internal members of a class are mangled）

}
```
在Java中会出现 `java.io.NotSerializable-Exception`: 虽然序列化的是 `ButtonState`，因为在Java中在一个类中声明另一个类时，会默认变成内部类，内部类持有了外部类的引用，内部类可以直接使用外部类的引用，外部Button的序列化破坏了内部类的序列化，需要将`ButtonState`声明为`static`。

```kotlin
class Button : View {
    override fun getCurrentState(): State {
        return ButtonState();
    }

    override fun restoreState(state: State) {
    }

    class ButtonState : State {}
}
```
而在Kotlin中，默认内部类是`static`，如果想要将其变成内部类持有外部引用时，需要使用`inner`来声明，同时引用要通过`this@Outer`来使用。

```kotlin
class Outer {
    inner class Inner {
        fun getOuterReference(): Outer = this@Outer
    }
}
```

对应关系表如下：

|          Class A declared within another class B           | In Java        | In Kotlin     |
| :--------------------------------------------------------: | -------------- | ------------- |
| Nested class (doesn’t store a reference to an outer class) | static class A | class A       |
|     Inner class (stores a reference to an outer class)     | class A        | inner class A |

##  密封类（Sealed classes）

密封类是一种受限继承结构的类，直接子类必须嵌套在父类中

```kotlin
interface Expr

class Num(val value: Int) :Expr

class Sum(val left:Int,val right:Expr) :Expr

fun eval(e:Expr):Int = 
        when(e){
            is Num -> e.value
            is Sum -> eval(e.right)
            else -> 
                    throw IllegalArgumentException("unknown expression")
        }
```
在上述代码中，如果不使用密封类，需要添加不支持的异常情况。如果使用了密封类则不需要
```kotlin
sealed class Expr {

    class Num(val value: Int) : Expr()

    class Sum(val left: Int, val right: Expr) : Expr()
}


fun eval(e: Expr): Int =
        when (e) {
            is Expr.Num -> e.value
            is Expr.Sum -> eval(e.right)
        }
```
<img src="./Kotlin/images/06.png" style="zoom:50%;" />

### 2. 构造方法、属性

>  declaring a class with nontrivial constructors or properties

Kotlin中区分了主构造方法( `primary constructor`) 和从构造方法(`secondary constructor`),主构造方法声明在类体外部(outside of the class body)，而从构造方法在内部( declared in the class body)

#### 2.1. 构造方法、初始化
```kotlin
class User(val _nickName:String,//加_与属性区分
           val isSubscribed:Boolean = true){
    val nickname = _nickName
}

val alice = User("Alice")
println(alice.isSubscribed)
val bob = User("Bob",isSubscribed = false)
println(bob.isSubscribed)
```

```kotlin
class User constructor(nickname:String){
    val nickname:String
		//初始化语句块
    init {
        this.nickname = nickname
    }
}
```
加val来简化：属性的初始化使用构造方法提供的值：
```kotlin
class User(val nickname:String)
```
子类对父类的初始化：
```kotlin
open class User(val nickName: String){}

class TwitterUser(nickName:String):User(nickName){}
```
如果没有声明构造方法，会自动生成不带任何参数的默认构造方法，即使父类没有声明任何构造参数，子类也要显式调用：
```kotlin 
open class Button

class RidoButton:Button()
```
可以将构造方法私有：

```kotlin
class Secretive private constructor(){}
```

#### 2.2. 从构造体（Secondary constructors）

使用不同方式对父类进行初始化

```kotlin
open class View {
    constructor(ctx: Context) {}
    constructor(ctx: Context, attr: Attributes) {}
}
```
直接调用父类构造方法
```kotlin
class MyButton : View {
    constructor(ctx: Context) : super(ctx) {}
    
    constructor(ctx: Context,attr: Attributes):super(ctx,attr){}
}
```
委托实现
```kotlin
class MyButton : View {
    constructor(ctx: Context) : this(ctx,null) {}
    
    constructor(ctx: Context,attr: Attributes):super(ctx,attr){}
}
```

#### 2.3. 非默认属性(nontrivial properties)

属性声明的类型

```kotlin
//主构造方法属性
interface User {
    val nickname: String
}

//自定义getter
class PrivateUser(override val nickname: String) : User

class SubscribingUser(val email: String) : User {
    override val nickname: String
        get() = email.substringBefore('@')
}

//使用函数对属性进行初始化
class FacebookUser(val accountId:Int):User{
    override val nickname: String
        get() = getFacebookName(accountId)

    private fun getFacebookName(accountId: Int): String {
        return ""
    }
}
```
实现在接口中的属性：
```kotlin
interface User {
    val email:String
    val nickname: String
    get() = email.substringBefore('@')
}
```

#### 2.4. getter 与 setter

通过get和set访问支持字段（ backing field ）

> You may wonder what the difference is between making a property that has a backing field and one that doesn’t. The way you access the property doesn’t depend on whether it has a backing field. The compiler will generate the backing field for the property if you either reference it explicitly or use the default accessor implementation. If you provide custom accessor implementations that don’t use field (for the getter if the property is a val and for both accessors if it’s a mutable property), the backing field won’t be present.

```kotlin
class User(val name: String) {
    var address: String = "unspecified"
        set(value: String) {
            println("""Address was changed for $name:
            "$field" -> "$value".""".trimIndent())
            field = value
        }
}

 val user = User("Alice")
 user.address = "Beijing 46,10001 HD"
    
//Address was changed for Alice:
//"unspecified" -> "Beijing 46,10001 HD".    
```

#### 2.5. 属性可见性修改

```kotlin
class LengthCounter {
    var counter: Int = 0
        private set //不能在类外部修改这个属性

    fun addWord(word: String) {
        counter += word.length
    }
}

val lengthCounter = LengthCounter()
lengthCounter.addWord("Hi!")
println(lengthCounter.counter)
```

### 3. 数据类(data classes)与类委托(class delegation)

Kotlin的编译器会自动生成一些模板化的代码

#### 3.1. 通用方法

In Kotlin, the == operator is the default way to compare two objects: it compares their values by calling equals under the hood. 
```kotlin
class Client(val name: String, val postalCode: Int) {

    override fun equals(other: Any?): Boolean {
        if (other == null || other !is Client)
            return false
        return name == other.name &&
                postalCode == other.postalCode
    }

    override fun toString(): String {
        return "Client(name=$name,postalCode=$postalCode"
    }

    override fun hashCode(): Int {
        return name.hashCode() * 31 + postalCode
    }
}
```

#### 3.2. Data classes

 自动生成通用方法（autogenerated implementations of universal methods）

```kotlin
class Client(val name: String, val postalCode: Int) {

    override fun equals(other: Any?): Boolean {
        if (other == null || other !is Client)
            return false
        return name == other.name &&
                postalCode == other.postalCode
    }

    override fun toString(): String {
        return "Client(name=$name,postalCode=$postalCode"
    }

    override fun hashCode(): Int {
        return name.hashCode() * 31 + postalCode
    }

    fun copy(name: String = this.name,
             postalCode: Int = this.postalCode) = Client(name, postalCode)
}

fun main(args: Array<String>) {
    val bob = Client("Bob",911)
    println(bob)
    println(bob.copy(postalCode = 110))

}

//Client(name=Bob,postalCode=911
//Client(name=Bob,postalCode=110
```

#### 3.3. 类委托

Class delegation: using the “by” keyword

Kotlin中默认将类视为final，保证只有设计为可扩展的类才可以被继承。但是，经常会碰到类虽然没有被设计为可扩展的，但是需要向其增加一些其他行为，常见的解决方法是通过[**装饰器模式**](http://zhengjing.life/2019/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%8C%EF%BC%9AStructural%20Pattern/)来实现。这种模式的本质是创建一个新类，实现原始类一样的接口，在装饰类中将原来的类实例作为字段保存，装饰类中通过转发到原始类的实例上就可以实现。如：

```kotlin
class DelegatingCollection<T> :Collection<T>{

    private val innerList = arrayListOf<T>()

    override val size: Int
        get() = innerList.size

    override fun contains(element: T): Boolean =
            innerList.contains(element)

    override fun containsAll(elements: Collection<T>): Boolean =
            innerList.containsAll(elements)

    override fun isEmpty(): Boolean =
            innerList.isEmpty()

    override fun iterator(): Iterator<T> =
            innerList.iterator()
    
}
```

在Kotlin中可以通过委托来简化这一操作，编译器会帮你自动生成：

```kotlin
class DelegatingCollection<T>(
        innerList: Collection<T> = ArrayList<T>()
) : Collection<T> by innerList {}
```



对于需要修改的行为可以通过复写相应的方法来实现：

```kotlin
class CountingSet<T>(
        val innerSet: MutableCollection<T> = HashSet()
) : MutableCollection<T> by innerSet {
    var objectsAdded = 0

    override fun add(element: T): Boolean {
        objectsAdded++
        return innerSet.add(element)
    }

    override fun addAll(elements: Collection<T>): Boolean {
        objectsAdded += elements.size
        return innerSet.addAll(elements)
    }
}


fun main(args: Array<String>) {
    val cset = CountingSet<Int>()
    cset.addAll(listOf(1, 1, 2))
    println("${cset.objectsAdded} objects were added ,${cset.size} remain")
}

//3 objects were added ,2 remain
```



### object关键字

主要用于定义类和创建实例对象（creates an instance (in other words, an object)）

- 定义单例：`Object` declaration is a way to define a singleton.
- 定义伴生对象：`Companion objects` can contain **factory methods** and other methods that are related to this class but don’t require a class instance to be called. Their members can be accessed via class name.
- 匿名内部类使用：`Object` expression is used instead of Java’s anonymous inner class.

#### 4.1. 简化单例定义

```kotlin
object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
        for (person in allEmployees) {}
    }
}
```

实现忽略大小写比较文件路径的比较器：

```kotlin
//Implementing Comparator with an object
object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(f1: File, f2: File): Int {
        return f1.path.compareTo(f2.path, ignoreCase = true)
    }
}
```

可以在类中声明：


```kotlin
//Implementing Comparator with a nested object
data class Person(val name: String) {
    object NameComparator : Comparator<Person> {
        override fun compare(p1: Person, p2: Person): Int {
            return p1.name.compareTo(p2.name)
        }

    }
}
```

调用：

```kotlin
fun main(args: Array<String>) {
    Payroll.calculateSalary()
		
    //可以在任意地方使用单例对象
    println(CaseInsensitiveFileComparator.compare(
            File("/User"), File("/user")
    ))//0

    val persons = listOf(Person("Bob"), Person("Alice"))
    //使用了sortedWith函数，该函数根据特定的比较器返回排序后的列表
    println(persons.sortedWith(Person.NameComparator))
    //[Person(name=Alice), Person(name=Bob)]
}
```



kotlin中object声明，在Java中会被转换为Instance，所以如果在Java中使用Kotlin的该声明时，可以通过：

```java
CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);
```



#### 4.2. 伴生对象(Companion objects)

 a place for factory methods and static members

Kotlin中类不能拥有静态成员，在Kotlin没有static字段。使用object和包级别的顶层函数来替代，但是顶层函数无法访问类的私有成员。（Private members can’t be used in top-level functions outside of the class.）如图：

<img src="http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/05.png" alt="img" style="zoom:40%;" />

可以通过伴生对象实现通过类名来直接访问方法，类似于Java中的静态方法。

```kotlin
class A{
    companion object {
        fun bar(){
            println("Companion object called")
        }
    }
}

>>> A.bar()
```
当我们想要不直接通过类的实例化来访问操作类本身时，可以通过声明为类的成员来达到目的，如**工厂方法**。

> if you need to write a function that can be called without having a class instance but needs access to the internals of a class, you can write it as **a member of an object** declaration inside that class.An example of such a function would be a **factory method**.



如果不希望直接访问类的构造函数，将其私有化后，可通过伴生对象来实现对其实例化访问,类似于工厂方法，如下面的例子：

> The companion object has access to all `private` members of the class, including the `private constructor`, and it’s an ideal candidate to implement **the Factory pattern**.



- 通过定义多个从构造方法(secondary constructors)来达到
```kotlin
class User{
    val nickname :String
    
    constructor(email:String){
        nickname = email.substringBefore('@')
    }
    
    constructor(facebookAccountId:Int){
        nickname = getFacebookName(facebookAccountId)
    }

    private fun getFacebookName(facebookAccountId: Int): String {
        return "facebook_$facebookAccountId"
    }
}
```
- 通过伴生对象实现工厂方法来替代从构造方法
```kotlin
class User private constructor(val nickname: String) {
    companion object {
        fun newSubscribeingUser(email: String) =
                User(email.substringBefore('@'))

        fun newFacebookUser(accountId: Int) =
                User(getFacebookName(accountId))
    }
}


val subscribingUser = User.newSubscribeingUser("bob@gmail.com")
val faceBookUser = User.newFacebookUser(4)
println(subscribingUser.nickname)
```

#### 4.3. 伴生对象作为普通对象

Companion objects as regular objects

对伴生对象命名使用：

```kotlin
class Person(val name:String){
    companion object Loader{
        fun fromJSON(jsonText:String):Person = ...
    }
}

fun main(args: Array<String>) {
    val person = Person.Loader.fromJSON("{name:'Dmitry'}")
    println(person.name)
}
```
伴生对象可以实行接口：

```kotlin
interface JSONSFactory<T> {
    fun fromJson(jsonText: String): T
}

class Person(val name: String) {
    companion object : JSONSFactory<Person> {
        override fun fromJson(jsonText: String): Person = Person(jsonText)
    }
}


fun <T> loadFromJson(factory: JSONSFactory<T>, json: String): T {
    return factory.fromJson(json)
}


fun main(args: Array<String>) {
    val json = loadFromJson(Person, "json数据")
    println(json.name)
}
```
> 伴生对象会被编译为常规对象，如果伴生对象没有命名，在Java中通过Companion引用来访问：
>
> ```java
> /* Java */
> Person.Companion.fromJSON("...");
> ```
>
> 如果想要object中的成员是静态的可以添加`@JvmStatic`和 `@JvmField`
>
> ```kotlin
> class Company{
>  object Employee{
>      @JvmStatic
>      var title = "boss"
> 
>      @JvmField
>      var person:Person = Person("Jame")
>  }
> }
> ```
>
> 

伴生对象可以进行扩展函数的声明：


```kotlin
class Person(val fistname:String,val lastName:String){
    companion object {

    }
}
//声明一个扩展函数
fun Person.Companion.fromJSON(json:String):Person{

}
//调用
val p = Person.fromJSON("json")
```

#### 4.4. Object:匿名内部类使用

Object expressions: anonymous inner classes rephrased

不同于Java在匿名内部类中，Kotlin可以修改表达式中的值

```kotlin
import java.awt.Window
import java.awt.event.MouseAdapter

fun countClicks(window: Window){
    var clickCount = 0

    window.addMouseListener(object :MouseAdapter(){
        override fun mouseClicked(e: java.awt.event.MouseEvent?) {
           clickCount++
        }
    })
}
```

在java中：

```java
 public void countClicks(Window window){
         int clickCount =0;
        window.addMouseListener(new MouseAdapter() {
            int result = clickCount+1;
        });
    }
```