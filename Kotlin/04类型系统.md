##  nullability

Kotlin对`NullPointerException`的处理是把它转变为编译期的错误。null类型需要显式指定，如`Type?`表示 `Type or null`。

对不支持`null`类型的需要特殊处理：

```kotlin
fun strLenSafe(s: String?): Int = if (s != null) s.length else 0
```

### 符号`?.`

```kotlin
fun printAllCaps(s: String?) {
    val allCaps: String? = s?.toUpperCase()
    println(allCaps)
}

fun main(args: Array<String>) {
    printAllCaps("abc")
    printAllCaps(null)
}

//ABC  null
```

```kotlin
class Employee(val name: String, val manager: Employee?)

fun managerName(employee: Employee): String? = employee.manager?.name

fun main(args: Array<String>) {
    val ceo = Employee("Da Boss", null)
    val developer = Employee("Bob Smith", ceo)
    println(managerName(developer))
    println(managerName(ceo))
}

//Da Boss
//null
```

```kotlin
class Address(val streetAddress: String, val zipCode: Int,
              val city: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
   val country = this.company?.address?.country
   return if (country != null) country else "Unknown"
}

fun main(args: Array<String>) {
    val person = Person("Dmitry", null)
    println(person.countryName())
}
//Unknown
```

#### 1.4. Elvis operator: “?:”
![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/23.jpg)

```kotlin
fun strLenSafe(s: String?): Int = s?.length ?: 0

fun main(args: Array<String>) {
    println(strLenSafe("abc"))
    println(strLenSafe(null))
}
//3 0
```

```kotlin
class Address(val streetAddress: String, val zipCode: Int,
              val city: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun printShippingLabel(person: Person) {
    val address = person.company?.address
      ?: throw IllegalArgumentException("No address")
    with (address) {
        println(streetAddress)
        println("$zipCode $city, $country")
    }
}

fun main(args: Array<String>) {
    val address = Address("Elsestr. 47", 80687, "Munich", "Germany")
    val jetbrains = Company("JetBrains", address)
    val person = Person("Dmitry", jetbrains)
    printShippingLabel(person)
    printShippingLabel(Person("Alexey", null))
}
//Exception in thread "main" java.lang.IllegalArgumentException: No address
//Elsestr. 47
//80687 Munich, Germany
```

#### 1.5. Safe casts: “as?”

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/27.jpg)

```kotlin
class Person(val firstName: String, val lastName: String) {
   override fun equals(o: Any?): Boolean {
      val otherPerson = o as? Person ?: return false

      return otherPerson.firstName == firstName &&
             otherPerson.lastName == lastName
   }

   override fun hashCode(): Int =
      firstName.hashCode() * 37 + lastName.hashCode()
}

fun main(args: Array<String>) {
    val p1 = Person("Dmitry", "Jemerov")
    val p2 = Person("Dmitry", "Jemerov")
    println(p1 == p2)
    println(p1.equals(42))
}

// true false
```

#### 1.6. Not-null assertions: “!!”

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/10.jpg)

```kotlin
fun ignoreNulls(s: String?) {
    val sNotNull: String = s!!
    println(sNotNull.length)
}

fun main(args: Array<String>) {
    ignoreNulls(null)
}
```

#### 1.7. The “let” function

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/28.jpg)

```kotlin
fun sendEmailTo(email: String) {
    println("Sending email to $email")
}

fun main(args: Array<String>) {
    var email: String? = "yole@example.com"
    email?.let { sendEmailTo(it) }
    email = null
    email?.let { sendEmailTo(it) }
}

//Sending email to yole@example.com 
```

#### 1.8. Late-initialized properties

- Using non-null assertions to access a nullable property
```kotlin
import org.junit.Before
import org.junit.Test
import org.junit.Assert

class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private var myService: MyService? = null

    @Before fun setUp() {
        myService = MyService()
    }

    @Test fun testAction() {
        Assert.assertEquals("foo",
            myService!!.performAction())
    }
}
```

-  Using a late-initialized property
```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private lateinit var myService: MyService

    @Before fun setUp() {
        myService = MyService()
    }

    @Test fun testAction() {
        Assert.assertEquals("foo",
            myService.performAction())
    }
}
```

#### 1.9. Extensions for nullable types

```kotlin
fun verifyUserInput(input: String?) {
    if (input.isNullOrBlank()) {
        println("Please fill in the required fields")
    }
}

fun main(args: Array<String>) {
    verifyUserInput(" ")
    verifyUserInput(null)
}
```

#### 1.10. Nullability of type parameters

```kotlin
fun <T> printHashCode(t: T) {
    println(t?.hashCode())
}

fun main(args: Array<String>) {
    printHashCode(null)
}
//null
```

```kotlin
fun <T:Any> printHashCode(t: T) {
    println(t?.hashCode())
}

fun main(args: Array<String>) {
    //编译错误
    printHashCode(null)
}
```

#### 1.11. Nullability and Java

```kotlin
fun yellAtSafe(person: Person) {
    println((person.name ?: "Anyone").toUpperCase() + "!!!")
}

fun main(args: Array<String>) {
    yellAtSafe(Person(null))
}
//ANYONE!!!
```

## 数据类型

#### 2.2. Nullable primitive types: Int?, Boolean?, and more

Nullable types in Kotlin can’t be represented by Java primitive types, because null can only be stored in a variable of a Java reference type. That means whenever you use a nullable version of a primitive type in Kotlin, it’s compiled to the corresponding wrapper type.

```kotlin
data class Person(val name: String,
                  val age: Int? = null) {

    fun isOlderThan(other: Person): Boolean? {
        if (age == null || other.age == null)
            return null
        return age > other.age
    }
}

fun main(args: Array<String>) {
    println(Person("Sam", 35).isOlderThan(Person("Amy", 42)))
    println(Person("Sam", 35).isOlderThan(Person("Jane")))
}

//false
//null
```

#### 2.3. Number conversions
One important difference between Kotlin and Java is the way they handle numeric conversions. Kotlin doesn’t automatically convert numbers from one type to the other, even when the other type is larger.

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/22.jpg)

Instead, you need to apply the conversion explicitly:

```kotlin
val i = 1
val l: Long = i.toLong()
```

```kotlin
fun main(args: Array<String>) {
    val x = 1
    println(x.toLong() in listOf(1L, 2L, 3L))
    
    //编译错误
   // println(x in listOf(1L, 2L, 3L))
}
//true
```

```kotlin
fun foo(l: Long) = println(l)

fun main(args: Array<String>) {
    val b: Byte = 1
    val l = b + 1L
    foo(42)
    
    println("42".toInt())
}
```

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/09.jpg)

#### 2.4. “Any” and “Any?”: the root types
Similar to how `Object` is the root of the class hierarchy in Java, the `Any` type is the supertype of all **non-nullable** types in Kotlin. 

But in Java, Object is a supertype of all reference types only, and primitive types aren’t part of the hierarchy. That means you have to use wrapper types such as java.lang.Integer to represent a primitive type value when Object is required. In Kotlin, Any is a supertype of all types, including the primitive types such as Int.

Note that `Any` is a **non-nullable** type, so a variable of the type Any can’t hold the value `null`. If you need a variable that can hold any possible value in Kotlin, including `null`, you must use the `Any?` type.

Under the hood, the Any type corresponds to java.lang.Object. The Object type used in parameters and return types of Java methods is seen as Any in Kotlin. (More specifically, it’s viewed as a platform type, because its nullability is unknown.) When a Kotlin function uses Any, it’s compiled to Object in the Java bytecode.

#### 2.5. The Unit type: Kotlin’s “void”

The `Unit` type in Kotlin fulfills the same function as `void` in Java. It can be used as a return type of a function that has nothing interesting to return:

```kotlin
fun f(): Unit { ... }
```

#### 2.6. The Nothing type: “This function never returns”
For some functions in Kotlin, the concept of a “return value” doesn’t make sense because they never complete successfully. For example, many testing libraries have a function called fail that fails the current test by throwing an exception with a specified message. A function that has an infinite loop in it will also never complete successfully.

When analyzing code that calls such a function, it’s useful to know that the function will never terminate normally. To express that, Kotlin uses a special return type called Nothing

```kotlin
fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}

fun main(args: Array<String>) {
    fail("Error occurred")
}
```

## 集合和数组

#### 3.1. Nullability and collections

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/21.jpg)

```kotlin
fun readNumbers(reader: BufferedReader): List<Int?> {
    val result = ArrayList<Int?>()
    for (line in reader.lineSequence()) {
        try {
            val number = line.toInt()
            result.add(number)
        }
        catch(e: NumberFormatException) {
            result.add(null)
        }
    }
    return result
}

fun addValidNumbers(numbers: List<Int?>) {
    var sumOfValidNumbers = 0
    var invalidNumbers = 0
    for (number in numbers) {
        if (number != null) {
            sumOfValidNumbers += number
        } else {
            invalidNumbers++
        }
    }
    println("Sum of valid numbers: $sumOfValidNumbers")
    println("Invalid numbers: $invalidNumbers")
}

fun main(args: Array<String>) {
    val reader = BufferedReader(StringReader("1\nabc\n42"))
    val numbers = readNumbers(reader)
    addValidNumbers(numbers)
}

//Sum of valid numbers: 43
//Invalid numbers: 1
```

```kotlin
fun readNumbers(reader: BufferedReader): List<Int?> {
    val result = ArrayList<Int?>()
    for (line in reader.lineSequence()) {
        try {
            val number = line.toInt()
            result.add(number)
        }
        catch(e: NumberFormatException) {
            result.add(null)
        }
    }
    return result
}

fun addValidNumbers(numbers: List<Int?>) {
    val validNumbers = numbers.filterNotNull()
    println("Sum of valid numbers: ${validNumbers.sum()}")
    println("Invalid numbers: ${numbers.size - validNumbers.size}")
}

fun main(args: Array<String>) {
    val reader = BufferedReader(StringReader("1\nabc\n42"))
    val numbers = readNumbers(reader)
    addValidNumbers(numbers)
}
```

#### 3.2. Read-only and mutable collections
An important trait that sets apart Kotlin’s collection design from Java’s is that it separates interfaces for accessing the data in a collection and for modifying the data. 

To modify the data in the collection, use the kotlin.collections.Mutable-Collection interface. It extends the regular kotlin.collections.Collection and provides methods for adding and removing the elements, clearing the collection, and so on.

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/24.jpg)

```kotlin
fun <T> copyElements(source: Collection<T>,
                     target: MutableCollection<T>) {
    for (item in source) {
        target.add(item)
    }
}

fun main(args: Array<String>) {
    val source: Collection<Int> = arrayListOf(3, 5, 7)
    val target: MutableCollection<Int> = arrayListOf(1)
    copyElements(source, target)
    println(target)
}
```

```
val source: Collection<Int> = arrayListOf(3, 5, 7)
val target :Collection<Int> = arrayListOf(1)
//target 参数错误
copyElements(source, target)
```

#### 3.3. Kotlin collections and Java

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/20.jpg)

```java
public class CollectionUtils {
    public static List<String> uppercaseAll(List<String> items) {
        for (int i = 0; i < items.size(); i++) {
            items.set(i, items.get(i).toUpperCase());
        }
        return items;
    }
}
```

```kotlin
fun printInUppercase(list: List<String>) {
    println(CollectionUtils.uppercaseAll(list))
    println(list.first())
}

fun main(args: Array<String>) {
    val list = listOf("a", "b", "c")
    printInUppercase(list)
}
//[A, B, C]
//A
```

#### 3.4. Collections as platform types

```java
interface FileContentProcessor {
    void processContents(File path,
        byte[] binaryContents,
        List<String> textContents);
}
```

```kotlin
class FileIndexer : FileContentProcessor {
    override fun processContents(path: File,
        binaryContents: ByteArray?,
        textContents: List<String>?) {

        // ...
    }
}
```

```java
interface DataParser<T> {
    void parseData(String input,
        List<T> output,
        List<String> errors);
}
```

```kotlin
class PersonParser : DataParser<Person> {
    override fun parseData(input: String,
        output: MutableList<Person>,
        errors: MutableList<String?>) {

        // ...
    }
}
```

#### 3.5. Arrays of objects and primitive types

```kotlin
fun main(args: Array<String>) {
    for (i in args.indices) {
         println("Argument $i is: ${args[i]}")
    }
}
```

```kotlin
fun main(args: Array<String>) {
    val letters = Array<String>(26) { i -> ('a' + i).toString() }
    println(letters.joinToString(""))
}
```

```kotlin
fun main(args: Array<String>) {
    val strings = listOf("a", "b", "c")
    println("%s/%s/%s".format(*strings.toTypedArray()))
}
//a/b/c
```
To represent arrays of primitive types, Kotlin provides a number of separate classes, one for each primitive type. For example, an array of values of type Int is called IntArray. For other types, Kotlin provides ByteArray, CharArray, Boolean-Array, and so on. All of these types are compiled to regular Java primitive type arrays, such as int[], byte[], char[], and so on. Therefore, values in such an array are stored without boxing, in the most efficient manner possible.

```kotlin
val fiveZeros = IntArray(5)
val fiveZerosToo = intArrayOf(0, 0, 0, 0, 0)
```

```kotlin
fun main(args: Array<String>) {
    val squares = IntArray(5) { i -> (i+1) * (i+1) }
    println(squares.joinToString())
}
//1, 4, 9, 16, 25
```

```kotlin
fun main(args: Array<String>) {
    args.forEachIndexed { index, element ->
        println("Argument $index is: $element")
    }
}
```