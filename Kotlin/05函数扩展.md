## 重载运算符`operator`

### 二元算术运算符

| 表达式  | 对应函数     |
| ------- | ------------ |
| `a + b` | `a.plus(b)`  |
| `a - b` | `a.minus(b)` |
| `a * b` | `a.times(b)` |
| `a / b` | `a.div(b)`   |
| `a % b` | `a.rem(b)`   |

plus运算符：

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

fun main(args: Array<String>) {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)
    println(p1 + p2)
}
//Point(x=40, y=60)
```

运算符定义为扩展函数：
```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}

fun main(args: Array<String>) {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)
    println(p1 + p2)
}

```

使返回结果不同：

```kotlin
operator fun Char.times(count: Int): String {
    return toString().repeat(count)
}

fun main(args: Array<String>) {
    println('a' * 3)
}
//aaa
```
重新定义二元运算符后，复合运算符(compound assignment operators)也同时支持:

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}

fun main(args: Array<String>) {
    var point = Point(1, 2)
    point += Point(3, 4)
    println(point)
}
//Point(x=4, y=6)
```

### 一元运算符unary operators
|Expression | Function name|
| --| -- |
|+a	|unaryPlus |
|-a	|unaryMinus|
|!a	|not|
|++a, a++ |	inc|
|--a, a--	| dec|

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.unaryMinus(): Point {
    return Point(-x, -y)
}

fun main(args: Array<String>) {
    val p = Point(10, 20)
    println(-p)
}
// Point(x=-10, y=-20)
```

自增运算符：


```kotlin
operator fun BigDecimal.inc() = this + BigDecimal.ONE

fun main(args: Array<String>) {
    var bd = BigDecimal.ZERO
    println(bd++)
    println(++bd)
}
//0 2-+
```

## 比较运算符

### equals

在Kotlin中，`==`运算符会被转换为调用equals方法，`a==b`相当于`a?.equals(b) ?: (b==null)`。

```kotlin
class Point(val x: Int, val y: Int) {
    override fun equals(obj: Any?): Boolean {
        if (obj === this) return true
        if (obj !is Point) return false
        return obj.x == x && obj.y == y
    }
}

fun main(args: Array<String>) {
    println(Point(10, 20) == Point(10, 20))
    println(Point(10, 20) != Point(5, 5))
    println(null == Point(1, 2))
}
//true true false
```

### compareTo

比较(`<`,`>`,`<=`,`>=)`运算符将被转换为`compareTo`，如 `a >= b` 相当于 `a.compareTo(b) >= 0`

```kotlin
class Person(val firstName: String, val lastName: String) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValuesBy(this, other, Person::lastName, Person::firstName)
    }
}

fun main(args: Array<String>) {
    val p1 = Person("Alice", "Smith")
    val p2 = Person("Bob", "Johnson")
    println(p1 < p2)
}
// false

 println("abc" < "bac") //true
```

## 集合和区间相关运算符

### 角标索引运算符

使用角标索引运算符时，读取元素会被转换为get运算符，写入元素会被转换为set，`x[a, b]` 相当于调用 `x.get(a, b)`。

如通过索引来访问坐标点，p[0]访问x点坐标，p[1]访问y点坐标，实现get方法：

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.get(index: Int): Int {
    return when(index) {
        0 -> x
        1 -> y
        else ->
            throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

fun main(args: Array<String>) {
    val p = Point(10, 20)
    println(p[1])
}
```

实现set方法进行写入：

```kotlin
data class MutablePoint(var x: Int, var y: Int)

operator fun MutablePoint.set(index: Int, value: Int) {
    when(index) {
        0 -> x = value
        1 -> y = value
        else ->
            throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

fun main(args: Array<String>) {
    val p = MutablePoint(10, 20)
    p[1] = 42
    println(p)
}
```

### in

在集合中in用于检查某个对像是否属于集合，对应的方法为contains，如 `a in c` 相当于 `c.contains(a)`。

**开区间**是不包含最后一个点的区间，如 `10 until 20`；闭区间则包含最后一个点，如 `10..20`。实现in：

```kotlin
data class Point(val x: Int, val y: Int)

data class Rectangle(val upperLeft: Point, val lowerRight: Point)

operator fun Rectangle.contains(p: Point): Boolean {
    return p.x in upperLeft.x until lowerRight.x &&
           p.y in upperLeft.y until lowerRight.y
}

fun main(args: Array<String>) {
    val rect = Rectangle(Point(10, 20), Point(50, 50))
    println(Point(20, 30) in rect)
    println(Point(5, 5) in rect)
}
// true false
```

### rangeTo

区间语法`..`对应`rangeTo`函数，`start..end` 相当于 `start.rangeTo(end)`，只要实现了 `Comparable<T>`，Kotlin 标准库就自动为你提供了 `rangeTo` 的默认实现。

标准库源码：

```kotlin
public operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)
```

让自定义类支持 `..` 运算符：

```kotlin
data class Version(val major: Int, val minor: Int) : Comparable<Version> {
    override fun compareTo(other: Version): Int {
        return if (major != other.major) major - other.major
               else minor - other.minor
    }
}

// Comparable 已经提供了默认的 rangeTo 实现，无需额外定义
val v1 = Version(1, 0)
val v2 = Version(2, 0)
val current = Version(1, 5)

println(current in v1..v2)  // true
```

### Iterator

`Iterator` 是一个**迭代器接口**，用于逐个访问集合中的元素，是 `for` 循环的底层支撑。源码定义：

```kotlin
public interface Iterator<out T> {
    public operator fun next(): T         // 返回下一个元素
    public operator fun hasNext(): Boolean // 是否还有下一个元素
}

// 可变迭代器，额外支持删除
public interface MutableIterator<out T> : Iterator<T> {
    public fun remove(): Unit
}
```

Kotlin 的 `for` 循环会被编译器自动展开为迭代器调用,`iterator()` 也是一个 `operator` 函数，因此任何实现了 `operator fun iterator()` 的类都可以用 `for` 循环遍历

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> =
    object : Iterator<LocalDate> {
        var current = start
        override fun hasNext() = current <= endInclusive

        override fun next() = current.apply {
            current = plusDays(1)
        }
    }

fun main(args: Array<String>) {
    val newYear = LocalDate.ofYearDay(2017, 1)
    val daysOff = newYear.minusDays(1)..newYear
    for (dayOff in daysOff) {
        println(dayOff)
    }
}
// 2016-12-31 
// 2017-01-01
```

## 解构声明和组件函数

**解构声明**(destructuring declarations)允许将一个对像同时拆解赋值给多个变量，底层通过`componentN`函数(component functions)实现，N声明变量的位置，具体转化为：

```kotlin
val (a, b) = p
// 相当于
val a = p.component1()
val b = p.component2()
```

`data class` 会按主构造函数属性自动生成`componentN`：

```kotlin
data class Point(val x: Int, val y: Int)

fun main(args: Array<String>) {
    val p = Point(10, 20)
    val (x, y) = p
    println(x)
    println(y)
} // 10 20
```
解构声明可以用于从一个函数返回多个值：

```kotlin
data class NameComponents(val name: String, val extension: String)

fun splitFilename(fullName: String): NameComponents {
    val result = fullName.split('.', limit = 2)
    return NameComponents(result[0], result[1])
}

fun main(args: Array<String>) {
    val (name, ext) = splitFilename("example.kt")
    println(name)
    println(ext)
}
//example
//kt
```

用解构声明来遍历map：

```kotlin
fun printEntries(map: Map<String, String>) {
    for ((key, value) in map) {
        println("$key -> $value")
    }
}

fun main(args: Array<String>) {
    val map = mapOf("Oracle" to "Java", "JetBrains" to "Kotlin")
    printEntries(map)
}
//Oracle -> Java JetBrains -> Kotlin
```

## 委托属性

**委托属性(delegated properties)**是将操作对像的过程委托给另一个辅助对像，即将属性的`get/set`逻辑委托给辅助对像，复用属性访问逻辑(Reusing property accessor logic)。

基本语法：

```kotlin
class Person {
    var name: String by Delegate()  // 将 get/set 委托给 Delegate 对象
}
```

编译器会自动展开为：

```kotlin
class Person {
    private val delegate = Delegate()

    var name: String
        get() = delegate.getValue(this, ::name)
        set(value) { delegate.setValue(this, ::name, value) }
}
```

委托对像必须提供`getValue`和`setValue`方法

```kotlin
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "从委托中读取 ${property.name}"
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("向委托写入 ${property.name} = $value")
    }
}
```

### lazy委托

首次访问时初始化，之后使用缓存结果：

```kotlin
class Email {}
fun loadEmails(person: Person): List<Email> {
    println("Load emails for ${person.name}")
    return listOf()
}

class Person(val name: String) {
    private var _emails: List<Email>? = null
    val emails: List<Email>
        get() {
            if (_emails == null) {
                _emails = loadEmails(this)
            }
            return _emails!!
        }
}

fun main(args: Array<String>) {
    val p = Person("Alice")
    p.emails
    p.emails
}
```
使用委托属性简化：

```kotlin
class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
}
```

lazy默认是线程安全的，多线程环境下只初始化一次：

```kotlin
val data by lazy(LazyThreadSafetyMode.NONE) {  }         // 不加锁，单线程用
val data by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {  } // 默认，加锁
val data by lazy(LazyThreadSafetyMode.PUBLICATION) {  }  // 允许多次初始化，取第一个
```

### observable监听属性变化

通过`PropertyChangeSupport`工具类，手动实现属性变化监听，其中可通过`field`字段访问私有字段`backing fileld`：

```kotlin
open class PropertyChangeAware {
    protected val changeSupport = PropertyChangeSupport(this)
    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}

class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    var age: Int = age
        set(newValue) {
            val oldValue = field
            field = newValue
            // 属性变化时通知监听器
            changeSupport.firePropertyChange("age", oldValue, newValue)
        }

    var salary: Int = salary
        set(newValue) {
            val oldValue = field
            field = newValue
            changeSupport.firePropertyChange("salary", oldValue, newValue)
        }
}

fun main(args: Array<String>) {
    val p = Person("Dmitry", 34, 2000)
    p.addPropertyChangeListener { event ->
        println("Property ${event.propertyName} changed from ${event.oldValue} to ${event.newValue}")
    }
    p.age = 35
    p.salary = 2100
}
//Property age changed from 34 to 35
//Property salary changed from 2000 to 2100
```

增加辅助类`ObservableProperty`来实现监听变化：

```kotlin
open class PropertyChangeAware {
    protected val changeSupport = PropertyChangeSupport(this)
    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}

class ObservableProperty(val propName: String, var propValue: Int, val changeSupport: PropertyChangeSupport) {
    fun getValue(): Int = propValue
    fun setValue(newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        changeSupport.firePropertyChange(propName, oldValue, newValue)
    }
}

class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    val _age = ObservableProperty("age", age, changeSupport)
    var age: Int
        get() = _age.getValue()
        set(value) {
            _age.setValue(value)
        }

    val _salary = ObservableProperty("salary", salary, changeSupport)
    var salary: Int
        get() = _salary.getValue()
        set(value) {
            _salary.setValue(value)
        }
}

fun main(args: Array<String>) {
    val p = Person("Dmitry", 34, 2000)
    p.addPropertyChangeListener { event ->
        println("Property ${event.propertyName} changed from ${event.oldValue} to ${event.newValue}")
    }
    p.age = 35
    p.salary = 2100
}
```

`ObservableProperty`中的`getValue`和`setValue`被标记了`operator`，其函数变为两个参数，一个用于接收实例，另一个`KProperty`用于表示属性本身：

```kotlin
open class PropertyChangeAware {
    protected val changeSupport = PropertyChangeSupport(this)
    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}

class ObservableProperty(var propValue: Int, val changeSupport: PropertyChangeSupport) {
    operator fun getValue(p: Person, prop: KProperty<*>): Int = propValue

    operator fun setValue(p: Person, prop: KProperty<*>, newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        changeSupport.firePropertyChange(prop.name, oldValue, newValue)
    }
}

class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    // 使用委托属性来绑定更改通知
    var age: Int by ObservableProperty(age, changeSupport)
    var salary: Int by ObservableProperty(salary, changeSupport)
}

fun main(args: Array<String>) {
    val p = Person("Dmitry", 34, 2000)
    p.addPropertyChangeListener { event ->
        println("Property ${event.propertyName} changed from ${event.oldValue} to ${event.newValue}")
    }
    p.age = 35
    p.salary = 2100
}
```

使用`Delegates.observable`来实现属性委托：

```kotlin
open class PropertyChangeAware {
    protected val changeSupport = PropertyChangeSupport(this)
    fun addPropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.addPropertyChangeListener(listener)
    }

    fun removePropertyChangeListener(listener: PropertyChangeListener) {
        changeSupport.removePropertyChangeListener(listener)
    }
}

class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    private val observer = { prop: KProperty<*>, oldValue: Int, newValue: Int ->
        changeSupport.firePropertyChange(prop.name, oldValue, newValue)
    }

    var age: Int by Delegates.observable(age, observer)
    var salary: Int by Delegates.observable(salary, observer)
}

fun main(args: Array<String>) {
    val p = Person("Dmitry", 34, 2000)
    p.addPropertyChangeListener { event ->
        println("Property ${event.propertyName} changed from ${event.oldValue} to ${event.newValue}")
    }
    p.age = 35
    p.salary = 2100
}
```

### 属性委托过程

```kotlin
class C {
    var prop: Type by MyDelegate()
}

val c = C()
```
`MyDelegate`会被保存到一个隐藏的属性`<delegate>`中，编译器将用一个KProperty类型 `<property>`来代表这个属性：

```kotlin
class C {
    private val <delegate> = MyDelegate()

    var prop: Type
       get() = <delegate>.getValue(this, <property>)
       set(value: Type) = <delegate>.setValue(this, <property>, value)
}
```

在每个属性访问时，会生成对应方法，如 `val x = c.prop`会生成 `val x = <delegate>.getValue(c, <property>)`; 
而`c.prop = x`则会生成`<delegate>.setValue(c, <property>, x)`。

### 通过map来实现属性委托

能过定义一个属性，并把值存放到map中：

```kotlin
class Person {
    private val _attributes = hashMapOf<String, String>()

    fun setAttribute(attrName: String, value: String) {
        _attributes[attrName] = value
    }

    val name: String
        get() = _attributes["name"]!!
}

fun main(args: Array<String>) {
    val p = Person()
    val data = mapOf("name" to "Dmitry", "company" to "JetBrains")
    for ((attrName, value) in data)
       p.setAttribute(attrName, value)
    println(p.name)
}
```
可以通过委托属性直接从map中取，`p.name`隐藏的调用`_attributes.getValue(p, prop)`：

```kotlin
class Person {
    private val _attributes = hashMapOf<String, String>()

    fun setAttribute(attrName: String, value: String) {
        _attributes[attrName] = value
    }

    val name: String by _attributes
}
```