
### 1. generic type parameters

#### 1.1. Generic functions and properties


![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/50.jpg)

```kotlin
fun main(args: Array<String>) {
    val letters = ('a'..'z').toList()
    println(letters.slice<Char>(0..2))
    println(letters.slice(10..13))
}
```

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size - 2]

fun main(args: Array<String>) {
    println(listOf(1, 2, 3, 4).penultimate)
}
// 3
```


#### 1.2. Declaring generic classes

#### 1.3. Type parameter constraints

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/48.jpg)

```kotlin
fun <T : Number> oneHalf(value: T): Double {
    return value.toDouble() / 2.0
}

fun main(args: Array<String>) {
    println(oneHalf(3))
}
```

```kotlin
fun <T: Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}

fun main(args: Array<String>) {
    println(max("kotlin", "java"))
}
```

```kotlin
fun <T> ensureTrailingPeriod(seq: T)where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}

fun main(args: Array<String>) {
    val helloWorld = StringBuilder("Hello World")
    ensureTrailingPeriod(helloWorld)
    println(helloWorld)
}
// Hello World.
```
In this case, you specify that the type used as a type argument must implement both the CharSequence and Appendable interfaces. 

#### 1.4. Making type parameters non-null

```kotlin
class Processor<T>{
    fun process(value:T){
        value?.hashCode()
    }
}
```

```kotlin
class Processor<T:Any>{
    fun process(value:T){
        value.hashCode()
    }
}
```
The <T : Any> constraint ensures that the T type will always be a non-nullable type.

### 2. generics at runtime: erased and reified type parameters

#### 2.1. Generics at runtime: type checks and casts

```kotlin
fun printSum(c: Collection<*>) {
    val intList = c as? List<Int>
            ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

fun main(args: Array<String>) {
    printSum(listOf(1, 2, 3))
    printSum(listOf("a","b"))
}
// 6
//ClassCastException: java.lang.String cannot be cast to java.lang.Number
```

Let’s discuss the exception that’s thrown if you call the printSum function on a list of strings. You don’t get an IllegalArgumentException, because you can’t check whether the argument is a List<Int>. Therefore the cast succeeds, and the function sum is called on such a list anyway.

```kotlin
fun printSum(c: Collection<Int>) {
    if (c is List<Int>) {
        println(c.sum())
    }
}

fun main(args: Array<String>) {
    printSum(listOf(1, 2, 3))
}
```

#### 2.2. Declaring functions with reified type parameters

As we discussed earlier, Kotlin generics are erased at runtime, which means if you have an instance of a generic class, you can’t find out the type arguments used when the instance was created. The same holds for type arguments of a function. When you call a generic function, in its body you can’t determine the type arguments it was invoked with:
```kotlin
fun <T> isA(value: Any) = value is T
//Error: Cannot check for instance of erased type: T
```
This is true in general, but there’s one case where this limitation can be avoided: inline functions. Type parameters of inline functions can be reified, which means you can refer to actual type arguments at runtime.

```kotlin
inline fun <reified T> isA(value: Any) = value is T

fun main(args: Array<String>) {
    println(isA<String>("abc"))
    println(isA<String>(123))
}
```

```kotlin
fun main(args: Array<String>) {
    val items = listOf("one", 2, "three")
    println(items.filterIsInstance<String>())
}
//[one, three]
```

```kotlin
inline fun<reified T> Iterable<*>.filterIsInstance():List<T>{
    val destination = mutableListOf<T>()
    for (element in this){
        if (element is T){
            destination.add(element)
        }
    }
    return destination
}
```

> - Why reification works for inline functions only
> the compiler inserts the bytecode implementing the inline function into every place where it’s called. Every time you call the function with a reified type parameter, the compiler knows the exact type used as the type argument in that particular call. Therefore, the compiler can generate the bytecode that references the specific class used as a type argument. In effect, for the filter-IsInstance<String> call shown in listing 9.8, the generated code will be equivalent to the following:
> ![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/47.jpg)
Because the generated bytecode references a specific class, not a type parameter, it isn’t affected by the type-argument erasure that happens at runtime.

>Note that inline function with reified type parameters can’t be called from Java code. Normal inline functions are accessible to Java as regular functions—they can be called but aren’t inlined. Functions with reified type parameters require additional processing to substitute the type argument values into the bytecode, and therefore they must always be inlined. This makes it impossible to call them in a regular way, as the Java code does.

#### 2.3. Replacing class references with reified type parameters

```kotlin
val serviceImpl = ServiceLoader.load(Service::class.java)
```
`::class.java` syntax shows how you can get a java.lang.Class corresponding to a Kotlin class. This is an exact equivalent of Service.class in Java.

> Simplifying the startActivity function on Android
![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/53.jpg)


#### 2.4. Restrictions on reified type parameters

Even though reified type parameters are a handy tool, they have certain restrictions. Some are inherent to the concept, and others are determined by the current implementation and may be relaxed in future versions of Kotlin.

More specifically, here’s how you can use a reified type parameter:
- In type checks and casts (`is, !is, as, as?`)
- To use the Kotlin reflection APIs, as we’ll discuss in chapter 10 (`::class`)
- To get the corresponding java.lang.Class (`::class.java`)
- As a type argument to call other functions

You can’t do the following:

- Create new instances of the class specified as a type parameter
- Call methods on the companion object of the type parameter class
- Use a non-reified type parameter as a type argument when calling a function with a reified type parameter
- Mark type parameters of classes, properties, or non-inline functions as reified

### 3. variance: generics and subtyping

#### 3.1. Why variance exists: passing an argument to a function

```kotlin
fun printContents(list: List<Any>) {
    println(list.joinToString())
}

fun main(args: Array<String>) {
    printContents(listOf("abc", "bac"))
}
```

```kotlin
fun addAnswer(list: MutableList<Any>){
    list.add(42)
}

fun main(args: Array<String>) {
    val strings  = mutableListOf("abc","abd")
    addAnswer(strings)//编译错误
}
```

#### 3.2. Classes, types, and subtypes

the type of a variable specifies the possible values for this variable. We’ve sometimes used the terms **type** and **class** as equivalent, but they aren’t, and now is the time to look at the difference.

In the simplest case, with a non-generic class, the name of the class can be used directly as a type. For example, if you write var `x: String`, you declare a variable that can hold instances of the `String class`. But note that the same class name can also be used to declare a nullable type: `var x: String?`. This means each Kotlin class can be used to construct at least two types.

The story becomes even more complicated with generic classes. To get a valid type, you have to substitute a specific type as a type argument for the class’s type parameter. List isn’t a type (it’s a class), but all of the following substitutions are valid types: `List<Int>, List<String?>, List<List<String>>`, and so on. Each generic class produces a potentially infinite number of types.

In order for us to discuss the relation between types, you need to be familiar with the term **subtype**. A `type B` is a subtype of a `type A` if you can use the value of the type B whenever a value of the type A is required. For instance, Int is a subtype of Number, but Int isn’t a subtype of String. This definition also indicates that a type is considered a subtype of itself. 

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/51.jpg)

A non-null type A is a subtype of nullable A?, but not vice versa.

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/52.jpg)

The difference between subclasses and subtypes becomes especially important when we start talking about generic types. The question from the previous section of whether it’s safe to pass a variable of type `List<String>` to a function expecting `List<Any>` now can be reformulated in terms of subtyping: is `List<String>` a subtype of `List<Any>`？ You’ve seen why it’s not safe to treat `MutableList<String>`as a subtype of `MutableList<Any>`. Clearly, the reverse isn’t true either: `Mutable-List<Any>` isn’t a subtype of `MutableList<String>`.

The List interface in Kotlin represents a read-only collection. If `A` is a subtype of `B`, then List<A> is a subtype of List<B>. Such classes or interfaces are called **covariant**. 

#### 3.3. Covariance: preserved subtyping relation

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/49.jpg)

A covariant class is a generic class (we’ll use` Producer<T>` as an example) for which the following holds: `Producer<A>` is a subtype of `Producer<B>` if A is a subtype of B. We say that the subtyping is preserved. 

In Kotlin, to declare the class to be covariant on a certain type parameter, you put the `out` keyword before the name of the type parameter:

```
interface Producer<out T> {
    fun produce(): T
}
```

Marking a type parameter of a class as **covariant** makes it possible to pass values of that class as function arguments and return values when the type arguments don’t exactly match the ones in the function definition.

```kotlin
open class Animal{
    fun feed(){

    }
}

class Herd<T:Animal>{
    val size :Int get() = ...

    operator fun get(i: Int):T{
       ...
    }

}

 fun feedAll(animals: Herd<Animal>) {
        for (i in 0 until animals.size) {
            animals[i].feed()
        }
    }
    

class Cat:Animal(){
    fun clearnLitter(){
     }

    fun takeCareOfCats(cats:Herd<Cat>){
        for (i in 0 until cats.size){
            cats[i].clearnLitter()
        }
    }
}
```

```kotlin
class Herd<out T : Animal> {
    val size: Int get() = ...

    operator fun get(i: Int):T {
        ...
    }

}

fun feedAll(animals: Herd<Animal>) {
    for (i in 0 until animals.size) {
        animals[i].feed()
    }
}


class Cat : Animal() {
    fun clearnLitter() {

    }

    fun takeCareOfCats(cats: Herd<Cat>) {
        for (i in 0 until cats.size) {
            cats[i].clearnLitter()
        }

        feedAll(cats)
    }
}
```

To reiterate, the `out` keyword on the type parameter T means two things:

- The subtyping is preserved (`Producer<Cat>` is a subtype of `Producer<Animal>`).
- T can be used only in out positions.


Note that constructor parameters are in neither the in nor the out position. Even if a type parameter is declared as out, you can still use it in a constructor parameter declaration:

```kotlin
class Herd<out T: Animal>(vararg animals: T) { ... }
```
The variance protects the class instance from misuse if you’re working with it as an instance of a more generic type: you just can’t call the potentially dangerous methods. The constructor isn’t a method that can be called later (after an instance creation), and therefore it can’t be potentially dangerous.

#### 3.4. Contravariance: reversed subtyping relation

![](http://blog-open.oss-cn-beijing.aliyuncs.com/image/kotlin/46.jpg)

The concept of contravariance can be thought of as a mirror to covariance: for a contravariant class, the subtyping relation is the opposite of the subtyping relations of classes used as its type arguments. 

```kotlin
interface  Comparator<in T>{
    fun compare(e1:T,e2:T):Int{
       ...
    }
}
```

#### 3.5. Use-site variance: specifying variance for type occurrences

```kotlin
fun <T: R, R> copyData(source: MutableList<T>,
                       destination: MutableList<R>) {
    for (item in source) {
        destination.add(item)
    }
}
```

```kotlin
fun <T> copyData(source: MutableList<out T>,
                 destination: MutableList<T>) {
    for (item in source) {
        destination.add(item)
    }
}
```


```kotlin
fun <T> copyData(source: MutableList<T>,
                 destination: MutableList<in T>) {
    for (item in source) {
        destination.add(item)
    }
}
```

```kotlin
fun main(args: Array<String>) {
    val ints = mutableListOf(1, 2, 3)
    val anyItems = mutableListOf<Any>()
    copyData(ints, anyItems)
    println(anyItems)
}
```

#### 3.6. Star projection: using * instead of a type argument
the special star-projection syntax you can use to indicate that you have **no information about a generic argument**.

note that `MutableList<*>` isn’t the same as `MutableList<Any?>` (it’s important here that `MutableList<T>` is invariant on T). A `MutableList<Any?>` is a list that you know can contain elements of any type. On the other hand, a `Mutable-List<*>` is a list that contains elements of a specific type, but you don’t know what type it is.(you can’t create a new `ArrayList<*>`)

```kotlin
val list:MutableList<Any?> = mutableListOf("a",1,"qwe")
val chars = mutableListOf('a','b','c')
val unkonownElements:MutableList<*> = if (Random().nextBoolean()) list else chars

//unkonownElements.add() 错误
print(unkonownElements.first())
```

```kotlin
fun printFirst(list: List<*>) {
    if (list.isNotEmpty()) {
        println(list.first())
    }
}

fun main(args: Array<String>) {
    printFirst(listOf("Svetlana", "Dmitry"))
}
```

```kotlin
fun <T> printFirst(list: List<T>) {
    if (list.isNotEmpty()) {
        println(list.first())
    }
}

fun main(args: Array<String>) {
    printFirst(listOf("Svetlana", "Dmitry"))
}
```

```kotlin
import kotlin.reflect.KClass

interface FieldValidator<in T> {
    fun validate(input: T): Boolean
}

object DefaultStringValidator : FieldValidator<String> {
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator<Int> {
    override fun validate(input: Int) = input >= 0
}

fun main(args: Array<String>) {
    val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    validators[String::class] = DefaultStringValidator
    validators[Int::class] = DefaultIntValidator
}

```


```kotlin
interface FieldValidator<in T> {
    fun validate(input: T): Boolean
}

object DefaultStringValidator : FieldValidator<String> {
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator<Int> {
    override fun validate(input: Int) = input >= 0
}

object Validators {
    private val validators =
            mutableMapOf<KClass<*>, FieldValidator<*>>()

    fun <T: Any> registerValidator(
            kClass: KClass<T>, fieldValidator: FieldValidator<T>) {
        validators[kClass] = fieldValidator
    }

    @Suppress("UNCHECKED_CAST")
   // operator fun <T: Any> get(kClass: KClass<T>): FieldValidator<T> =
        validators[kClass] as? FieldValidator<T>
                ?: throw IllegalArgumentException(
                "No validator for ${kClass.simpleName}")
}

fun main(args: Array<String>) {
    Validators.registerValidator(String::class, DefaultStringValidator)
    Validators.registerValidator(Int::class, DefaultIntValidator)
    println(Validators[String::class].validate("Kotlin"))
    println(Validators[Int::class].validate(42))
}
//true
//true
```
