[Linux操作系统分析 - 中国科学技术大学 - 学堂在线](https://www.xuetangx.com/course/USTC08091000586/23895781)

[EAX x86 Register: Meaning and History (keleshev.com)](https://keleshev.com/eax-x86-register-meaning-and-history/)



#### 堆栈相关的寄存器

- esp : 堆栈指针（stack pointer）
- ebp : 基址指针（base pointer），c语言中用作记录当前函数调用基址

#### CS寄存器

CS(code segment)代码段寄存器，与IP寄存器结合起来组成完整的地址，CPU会将CS的值左移4位与IP寄存器相加，从而得到指令的物理地址。

- EIP(Extended Instruction Pointer)扩展指令指针，指向处理器将要执行的下一条指令地址，在32位寄存器（64中扩展为RIP）中：

```
EIP = 当前指令 + 指令长度
```

- call : 将当前cs:eip的值压入栈顶，cs:eip指向入口地址
- ret：从栈顶弹出保存在这里的值，放入cs:eip中
- 跳转：cs:eip的值会根据需要被修改

| Example instruction | What it does                                                 |
| ------------------- | ------------------------------------------------------------ |
| Pushl %eax          | Subl $4, %esp   //栈顶指针减4，栈在向下生长一个位置<br/>Movl %eax, (%esp) //将eax中的值放入栈顶指针指向的内存位置 |
| Popl %eax           | Movl (%esp), %eax //从栈顶指针指向的内存中的值放入eax中<br/>Addl $4, %esp //栈顶指针加4，栈在向上收缩 |
| Call 0x12345        | Pushl %eip //eip压栈<br/>Movl $0x12345, %eip //将0x12345放入eip中 |
| Ret                 | Popl %eip //ip出栈                                           |

| 寻址模式                | 格式            | 示例                                          |
| ----------------------- | --------------- | --------------------------------------------- |
| 寄存器寻址 registermode | %寄存器         | %edx 访问寄存器edx                            |
| 立即寻址 immediate      | $数字           | $0x123                                        |
| 直接寻址 direct         | 数字            | x123访问地址0x123指向的内存                   |
| 间接寻址 indirect       | (%寄存器)       | (%ebx)  访问寄存器ebx中的地址指向的内存       |
| 变址寻址 displaced      | 偏移量(%寄存器) | 4(%ebx)：访问寄存器ebx中的地址再加4指向的内存 |

函数调用框架：

1. call指令将eip中的下一条指令的地址A保存在栈顶
2. 设置eip指向被调用程序代码开始处
3. 调用完成，ret 将A恢复到eip中

```assembly
// 调用者
...
call target
...
```

```assembly
// 建立被调用函数框架
pushl %ebp
movl %esp, %ebp

 // 被调用函数
 do sth

// 拆除框架
movel %ebp, %esp
pop %ebp
ret
```



```
Pushl %eip //ip压栈
Movl $0x12345, %eip //将0x12345放入eip中
```

### 实验

```cpp
#include <stdio.h>

void p1(char c)
{
    printf("%c\n", c);
}

int p2(int x, int y)
{
    return x + y;
}

int main(void)
{
    char c = 'a';
    int x,y,z;
    x = 1;
    y = 2;
    p1(c);
    z = p2(x, y);
    printf("%d=%d+%d\n", z, x, y);
}
```

编译

```

```

