### 运算符

- 一元运算符(Unary operators)：作用于一个运算对像，如取址符(&)，解引用符(*)
- 二元运算符(Binary operators)：作用于二个运算对像，如(==)(*)

此外还有三元运算符，函数也是一种运算符。

#### 算术运算符

(Arithmetic Operators)

| Operator | Function      | Use         |
| :------: | ------------- | ----------- |
|    +     | unary plus    | +expr       |
|    -     | unary minus   | - expr      |
|    *     | multipliction | expr * expr |
|    /     | division      | expr / expr |
|    %     | remainder     | expr % expr |
|    +     | addition      | expr + expr |
|    -     | substraction  | expr -expr  |

#### 逻辑关系运算符

(Logical and Relational Operators)

```cpp
! 
<    <=    >   >=  
==   !=
&&  ||
```

#### 赋值运算符

```cpp
int i = 1;
```

#### 递增递减运算符

(Increment and Decrement Operators)

后置递增运算符的优先级高于解引用运算符

```cpp
// *pbeg++ 等价于 *(pbeg++)
vector<int> v{1, 2, 3, -1};
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```

#### 成员访问运算符

(The Member Access Operators)

点运算符和->运算符，ptr->mem 等价于 (*ptr).mem

```c
string s1 = "a string", *p = &s1;
auto n = s1.size(); // run the size member of the string s1
n = (*p).size();    // run size on the object to which p points
n = p->size();      //等价于 (*p).size()

// run the size member of p, then dereference the result!
*p.size();    // error: p是指针，没有size成员
```

#### 条件运算符

(Conditional Operator)

```cpp
cond ? exp1 : exp2;
```

#### 位运算符

The Bitwise Operators， 也叫IO运算符

```cpp
~ 取反  << 左移   >> 右移  &与  ^异或  |或
```

#### sizeof运算符

返回表达式或类型所占字节数，返回的是`size_t`类型的常量表达式，运算符的运算对像有两种形式：

```cpp
sizeof (type)
sizeof expr
```

第二种返回的是表达式的类型大小，不计算实际运算的值

```cpp
Sales_data data, *p;
sizeof(Sales_data); // 存储Sales_data类型所占的空间大小
sizeof data; // data类型大小， sizeof(Sales_data)
sizeof p;    // 指针所占大小
sizeof *p;   // 指针所指向类型大小, sizeof(Sales_data)
sizeof data.revenue; // Sales_data's revenue 大小
sizeof Sales_data::revenue; // 另一种方式获取Sales_data's revenue 大小
```

对数组进行sizeof运算，相当于整个数组所占空间的大小，根据这特性可以获取数组元素个数：

```cpp
constexpr size_t size = sizeof (ia) / sizeof(* ia);
```

#### 逗号运算符

Comma Operator

```cpp
vector<int>::size_type cnt = ivec.size();
// assign values from size... 1 to the elements in ivec
for(vector<int>::size_type ix = 0;ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```

### 类型转换

Type Conversions

#### 隐式转换

隐式转换(Implicit Conversion)：类型转换自动完成

```c
int ival = 3.541 + 3; // 精度丢失 the compiler might warn about loss of precision
```

算术转换(The Arithmetic Conversions)：把一种算术类型转换成另一种算术类型。

```cpp
bool      flag;         char           cval;
short     sval;         unsigned short usval;
int       ival;         unsigned int   uival;
long      lval;         unsigned long  ulval;
float     fval;         double         dval;
3.14159L + 'a'; //  'a' promoted to int, then that int converted to long double
dval + ival;    //  ival converted to double
dval + fval;    //  fval converted to double
ival = dval;    //  dval converted (by truncation) to int
flag = dval;    //  if dval is 0, then flag is false, otherwise true
cval + fval;    //  cval promoted to int, then that int converted to float
sval + cval;    //  sval and cval promoted to int
cval + lval;    //  cval converted to long
ival + ulval;   //  ival converted to unsigned long
usval + ival;   //  promotion depends on the size of unsigned short and int
uival + lval;   //  conversion depends on the size of unsigned int and long
```

隐式转换，数组转换成指针：

```cpp
int ia[10]; 
int* ip = ia; // ia转换成指向数组首元素的指针 convert ia to a pointer to the first element
```

从算术类型或指针类型向布尔类型自动转换的机制：


```cpp
char *cp = get_string();
if (cp) /* ... */      // true if the pointer cp is not zero
while (*cp) /* ...  */ // true if *cp is not the null character
```

指向非常量类型的指针转换成常量类型的指针：


```cpp
int i;
const int &j = i;  // convert a nonconst to a reference to const int
const int *p = &i; // convert address of a nonconst to the address of a const
int &r = j, *q = p; // error: conversion from const to nonconst not allowed
```

类类型转换:


```cpp
string s, t = "a value";  // character string literal converted to type string
while (cin >> s)          // while condition converts cin to bool
```

#### 显式转换

 显式转换(Explicit Conversions)，一种强制类型转换的命名方式：

```cpp
cast-name<type>(expression);
```

cast-name可以是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`

##### static_cast

任何有明确定义的类型转换，只要不包含底层const的类型，可使用static_cast进行转换

```cpp
// 强制类型转换，进行浮点数除法 cast used to force floating-point division
double slope = static_cast<double>(j) / i;
```

 当较大的算术类型赋值给较小的时，不在乎精度损失时，static_cast会非常有用。也可用于编译器无法自动执行类型转换，如用static_cast找回存在于void*指针中的值：

```cpp
void* p = &d;   // 任何非常量对象的地址都可存入void*中 address of any nonconst object can be stored in a void*
// 将void*转换回初始的指针类型 converts void* back to the original pointer type
double *dp = static_cast<double*>(p);
```

##### const_cast

`const_cast`只能改变底层const(**low-level const**)


```cpp
const char *pc;
char *p = const_cast<char*>(pc); // ok，但通过p写值是未定义的行为 but writing through p is undefined
```

通过将常量对象改变为非常量对象的行为，称为”去掉const性质“(cast away the const)。一旦去掉const性质，编译器就不再阻止对该对象进行写操作了。

不能用const_cast改变表达式的类型：

```cpp
const char *cp;
// error:不能去掉const性质 static_cast can't cast away const
char *q = static_cast<char*>(cp);

static_cast<string>(cp); // ok:字符串literal转换成string类型 converts string literal to string
const_cast<string>(cp);  // error:const_cast只能改变常量属性 const_cast only changes constness
```

const_cast常用于有函数重载的上下文中。

##### reinterpret_cast

`reinterpret_cast`通常为对象的位模式提供低层次上的解释(A `reinterpret_cast` generally performs a low-level reinterpretation of the bit pattern of its operands)。


```cpp
int *ip;
// pc所指的对象是int类型，而非字符
char *pc = reinterpret_cast<char*>(ip);
// 如果把pc当作普通字符指针使用，可能发生运行时异常
string str(pc);
```

##### dynamic_cast

dynamic_cast用于将基类的指针或引用安全地转换为派生类的指针或引用。

##### Old-Style Casts

```cpp
type (expr); // function-style cast notation
(type) expr; // C-language-style cast notation

char *pc = (char*) ip; // ip is a pointer to int
```

### 语句statement

for

```cpp
vector<int> v = {0,1,2,3,4,5,6,7,8,9};
for (auto &r : v) {
    r *= 2; 
}
```

do-while

```cpp
    string rsp; // used in the condition; can’t be defined inside the do
    do {
        cout << "please enter two values: ";
        int val1 = 0, val2 = 0;
        cin >> val1 >> val2;
        cout << "The sum of " << val1 << " and " << val2
             << " = " << val1 + val2 << "\n\n"
             << "More? Enter yes or no: ";
        cin >> rsp;
    } while (!rsp.empty() && rsp[0] != ’n’);
```

