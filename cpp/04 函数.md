
## 函数
函数包含函数名称、返回类型、形参(parameter)，通过调用运算符(call operator)来执行函数。实参(arguments)是形参的初始值。形参列表：

```cpp
void f1(){ /* ... */ }     // implicit void parameter list 隐式定义
void f2(void){ /* ... */ } // explicit void parameter list 显式定义
int f3(int v1, v2) { /* ... */ }     // error
int f4(int v1, int v2) { /* ... */ } // ok
```

### 局部对象(Local Objects)

对象具有生命周期，在函数执行过程中对象存在一段时间。函数内部定义的变量称为**局部变量**(local variables)，局部变量只在函数执行期间存在，在定义块末尾时销毁，这种对象也叫**自动对象(Automatic Objects)**。对于传递给函数的实参，如果未给初始化值，则进行默认初始化。

局部静态对象(Local static Objects)：将局部变量定义为static，局部静态对象会在程序终止时才销毁。如下面的程序会输出1-10。

```cpp
size_t count_calls()
{
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}
int main()
{
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}.
```
### 函数声明

Function Declarations，也叫函数原型(**function prototype**)，通常定义在头文件中，也可写在源文件中。

```cpp
// parameter names chosen to indicate that the iterators denote a range of values to print
void print(vector<int>::const_iterator beg,
           vector<int>::const_iterator end);
```

### 分离式编译(Separate Compilation) 

声明头文件和实现文件放置在不同的文件中。

`LocalMath.h`

```cpp
// not included in book text, but used by programs in this directory
#ifndef LOCALMATH_H
#define LOCALMATH_H

//definition in LocalMath.cc
int fact(int);        // iterative definition of factorial
int factorial(int);   // recrusive version of factorial
int gcd(int, int);    // find greatest common divisor
#endif
```
`LocalMath.c`
```cpp
#include "LocalMath.h"

// return the greatest common divisor
int gcd(int v1, int v2)
{
    while (v2) {
        int temp = v2;
        v2 = v1 % v2;
        v1 = temp;
    }
    return v1;
}


// factorial of val is val * (val - 1) *  (val - 2) . . . * ((val -  (val - 1)) * 1)
int fact(int val)
{
	int ret = 1; // local variable to hold the result as we calculate it
	while (val > 1) 
		ret *= val--;  // assign ret * val to ret and decrement val
	return ret;        // return the result
}

// recursive version of factorial:
// calculate val!, which is 1 * 2 * 3 . . . * val
int factorial(int val)
{
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}
```
`fact.cc`

```cpp
#include <iostream>
using std::cout; using std::endl;

// declarations of our factorial functions
// definitions are in LocalMath.cc
#include "LocalMath.h"

int main()
{
	cout << factorial(5) << endl;
	cout << fact(5) << endl;
	cout << factorial(0) << endl;
	cout << fact(0) << endl;

	return 0;
}
```

编译(CC为编译器名称)：

```shell
$ CC LocalMath.cc fact.cc   # generates LocalMath.exe or a.out
$ CC LocalMath.cc fact.cc -o main # generates main or main.exe
```
## 参数传递(Argument Passing)

当形参是引用类型时，将被绑定到对应的实参上，实参被**引用传递**( passed by reference)，函数被**传引用调用**(called by reference)；否则将实参的值拷贝后赋值给形参，形参和实参是两个独立的对象，进行**值传递**(passed by value)，函数被**传值调用**(called by value)。

### 传值参数

Passing Arguments by Value

```cpp
int n = 0;             // ordinary variable of type int
int i = n;             // i is a copy of the value in n
i = 42;                // value in i is changed; n is unchanged

// 通过函数对变量val进行修改
ret *= val--; 
```

指针形参(Pointer Parameters)和非引用类型一样，进行指针copy时，copy的是指针的值，copy后是两个不同的指针， 通过指针可修改它所指向的对象：

```cpp
int n = 0, i = 42;
int *p = &n, *q = &i; 
*p = 40;              // value in n is changed; p is unchanged
p = q;                // p now points to i; values in i and n are unchanged
```

指针与上面类似：

```cpp
// 接受一个指针，指针所指的位置是0 function that takes a pointer and sets the pointed-to value to zero
void reset(int *ip)
{
    *ip = 0;  // 改变所指对象的值，changes the value of the object to which ip points
    ip = 0;   // 实参未变，改变了ip的局部copy changes only the local copy of ip; the argument is unchanged
}
```
调用：
```cpp
int i = 42;
reset(&i);                    // changes i but not the address of i
cout << "i = " << i << endl;  // prints i = 0
```

### 传引用参数

 Passing Arguments by Reference，对引用的操作实际上是作用在所引的对象上的：

```cpp
int n = 0, i = 42;
int &r = n;           // r is bound to n (i.e., r is another name for n)
r = 42;               // n is now 42
r = i;                // n now has the same value as i
i = r;                // i has the same value as n
```
下面的函数接收一个int对象的引用，然后将该对象的值置为0：
```cpp
// function that takes a reference to an int and sets the given object to zero
void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}
```
调用：
```cpp
int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0
```

copy大的对象时比较低效，可使用引用来避免(Using References to Avoid Copies)：

```cpp
// compare the length of two strings
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```
> 如果函数无意改变引用形参的值，最好设为const。Reference parameters that are not changed inside a function should be references to const.

可以使用引用形参返回额外的信息(Using Reference Parameters to Return Additional Information)，因为函数返回值只能有一个，可以通过传入引用形参返回多个信息：

```cpp
// s中c第一次出现的位置，occurs统计c出现的总次数
string::size_type find_char(const string &s, char c, string::size_type &occurs){
    auto ret = s.size();
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}
```
调用完成后，如果s中存在o，则返回第一次出现的位置，ctr记录出现的次数。如果没有，则返回s.size。
```cpp
auto index = find_char(s, 'o', ctr);
```
### const 形参和实参

const Parameters and Arguments

```cpp
const int ci = 42;     // we cannot change ci; const is top-level
int i = ci;            // ok: when we copy ci, its top-level const is ignored
int * const p = &i;    //ok,但不能对p重新赋值 const is top-level; we can't assign to p
*p = 0;                // ok: changes through p are allowed; i is now 0
```
形参顶层const会被忽略掉：
```cpp
void fcn(const int i) { /* fcn can read but not write to i */ }
void fcn(int i) { /* . . . */ } // error: 重复定义，const被忽略 redefines fcn(int)
```

Pointer or Reference Parameters and const，形参初始化和变量初始化一样：

```cpp
int i = 42;
const int *cp = &i; // ok: cp不能改变i，but cp can't change i
const int &r = i;   // ok: but r can't change i
const int &r2 = 42; // ok
int *p = cp;  // error: types of p and cp don't match 
int &r3 = r;  // error: types of r3 and r don't match
int &r4 = 42; // error: can't initialize a plain reference from a literal
```

```cpp
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i);   // 形参为int* parameter
reset(&ci);  // error: can't initialize an int* from a pointer to a const int object
reset(i);    // 形参为int& parameter
reset(ci);   // error: can't bind a plain reference to the const object ci
reset(42);   // error: can't bind a plain reference to a literal
reset(ctr);  // error: types don't match; ctr has an unsigned type
// ok: find_char's first parameter is a reference to const
find_char("Hello World!", 'o', ctr);
```

尽量使用常量引用，把函数不会改变的parameter定义成普通引用是一种常见的错误：

```cpp
// 不良设计，第一个参数的const去掉 bad design: the first parameter should be a const string&
string::size_type find_char(string &s, char c, string::size_type &occurs);
```

```cpp
// 编译时错误
find_char("Hello World", 'o', ctr);
```

```cpp
bool is_sentence(const string &s)
{
    // if there's a single period at the end of s, then s is a sentence
    string::size_type ctr = 0;
    return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1;
}
```

### 数组形参

Array Parameters，数组的两个特殊性质会对函数定义有影响：数组不允许copy，使用数组时会转换为指针。所以不能以值传递的方式传递数组。

```cpp
// 虽然形式不同，函数是等价的，每个函数的parameter都是const int*
void print(const int*);
void print(const int[]);   // 意图是作用于array
void print(const int[10]); // 期望包含多少元素，实际未必
```

```cpp
int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*
print(j);  // ok: j is converted to an int* that points to j[0]
```

因为数组是以指针形式传递给函数的，数组指针需要进行管理，通常有三种方式：

1. 通过标记指定数组长度(Using a Marker to Specify the Extent of an Array)，这种方式适用有明显结束标记的，如果int数组则不合适：

```cpp
void print(const char *cp)
{
    if (cp)          
        while (*cp)  // 指针所指字串不是空字符 so long as the character it points to is not a null character
            cout << *cp++; // 输出并将指针向前移动一个位置 print the character and advance the pointer
}
```

2. 使用标准库规范(Using the Standard Library Conventions)，通过提供首尾指针来控制，首尾指针通过标准库的begin和end函数来提供：

```cpp
void print(const int *begin, const int *end)
{
    while (begin != end)
        cout << *begin++ << endl; 
}

int j[2] = {0, 1};
//j转换成指向它首元素的指针 j is converted to a pointer to the first element in j
print(begin(j), end(j));
```

3. 通过增加一个显式传递数组长度的形参（Explicitly Passing a Size Parameter）

```cpp
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}

int j[] = { 0, 1 };
print(j, end(j) - begin(j));
```

数组引用形参(Array Reference Parameters)：

```cpp
// ok: parameter is a reference to an array; the dimension is part of the type
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}

int i = 0, j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i);   // error: argument is not an array of ten ints
print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints
```

多维数组传递(Passing a Multidimensional Array)：

```cpp
// matrix指向数组的首元素，该数组由10个整数构成
void print(int (*matrix)[10], int rowSize) { /* . . . */ }

int *matrix[10]; // 10个指针构成的数组
int (*matrix)[10]; //指向含有10个int数组的指针 

// 等价定义，编译器会忽略掉第一个维度，看起来是一个二维数组，实际上是指向含有10个int数组的指针 
void print(int matrix[][10], int rowSize) { /* . . . */ }
```

### 可变形参(Varying Parameters)
当不确定实参的数量时，c++11提供了两种方法：

1. initializer_list标准库模板(initializer_list Parameters)：initializer_list用于表示某种特定类型的数组。

```cpp
initializer_list<string> ls; // initializer_list of strings
initializer_list<int> li;    // initializer_list of ints
```

```cpp
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}

// expected, actual are strings
if (expected != actual)
    error_msg({"functionX", expected, actual});
else
    error_msg({"functionX", "okay"});
```

```cpp
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " " ;
    cout << endl;
}

if (expected != actual)
    error_msg(ErrCode(42), {"functionX", expected, actual});
else
    error_msg(ErrCode(0), {"functionX", "okay"}); 
```

2. 省略符(Ellipsis Parameters)：为了便于c++访问c代码设置的，这些代码使用了名为varargs的c标准库功能，省略符位于最后，有两种形式：

```cpp
void foo(parm_list, ...);
void foo(...);
```
## 返回类型

Return Types and the return Statement

### 无返回值类型

Functions with No Return Value

```cpp
void swap(int &v1, int &v2)
{
    if (v1 == v2)
        return;
    int tmp = v2;
    v2 = v1;
    v1 = tmp;
    // no explicit return necessary
}
```

### 有返回值

 Functions That Return a Value

```cpp
string make_plural(size_t ctr, const string &word, const string &ending) {
    return (ctr > 1) ? word + ending : word;
}
```
如果函数返回引用，该引用只是对象的一个别名，不会真正copy对象：
```cpp
const string &shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```
 不要返回局部对象的指针或引用(a Reference or Pointer to a Local Object)，当函数完成后，所占用的空间也被释放，函数终止意味着局部变量的引用不再有效的内存区域

```cpp
// 严重错误，disaster: this function returns a reference to a local object
const string &manip() {
    string ret;
    if (!ret.empty())
        return ret;     // WRONG: returning a reference to a local object!
    else
        return "Empty"; // WRONG: "Empty" is a local temporary string
}
```
上面两条return语句都将返回未定义的值，第一条返回局部对象的引用，第二条将字符串成一个局部临时string对象，当函数结束时，临时对象占用的空间随之释放；两条都指向不可用的内存空间。

引用返回左值(Lvalues)：

```cpp
char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}

int main() {
    string s("a value");
    cout << s << endl;   // prints a value
    get_val(s, 0) = 'A'; // changes s[0] to A
    cout << s << endl;   // prints A value
    return 0;
}
```

列表初始化返回值(List Initializing the Return Value)：

```cpp
#include <vector>
using std::vector;

vector<string> process() {
    if (expected.empty())
        return {};  // return an empty vector
    else if (expected == actual)
        return {"functionX", "okay"}; // return list-initialized vector
    else
        return {"functionX", expected, actual
 };
}
```

递归(Recursion)

```cpp
int factorial(int val){
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}
```

###  返回数组指针

数组不能被copy，函数不能返回数组，可以返回数组的指针或引用，通过使用定义类型别名来返回

```cpp
typedef int arrT[10];  // arrT is a synonym for the type array of ten ints
using arrtT = int[10]; // equivalent declaration of arrT; see 
arrT* func(int i);     // func returns a pointer to an array of five ints
```

数组维度的区分：
```cpp
int arr[10];          // arr is an array of ten ints
int *p1[10];          // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
```
返回数组指针的函数形式：
```cpp
// type类型，dimension数组大小
Type (*function(parameter_list))[dimension]

// 示例：
int (*func(int i))[10];
// func(int i)              函数入参类型是int
// (*func(int i))           可对函数调用的结果执行解引用操作
// (*func(int i))[10]       解引用将得到一个大小是10的数组
// int (*func(int i))[10]   得到的数组中的类型是int
```
使用尾置返回类型(a Trailing Return Type)简化上述声明：

```cpp
// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];
```

使用decltype声明返回类型，decltype并不负责将数组类型转换为指针，想要arrPtr表示指针，需要加*：

```cpp
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i){
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}
```
## 重载

```cpp
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

不允许两个函数除了返回类型不同外，其他都相同：

```cpp
Record lookup(const Account&);
bool lookup(const Account&);   // error: only the return type is different
```

下面两个类型看起来不同，实际上是相同的：

```cpp
Record lookup(const Account &acct);
Record lookup(const Account&); // parameter names are ignored

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&); // Telno and Phone are the same type
```

重载和const形参(Overloading and const Parameters) ，一个拥有顶层const的形参没法与另人个没有const的形参区分开来：

```cpp
Record lookup(Phone);
Record lookup(const Phone);   //重复声明 redeclares Record lookup(Phone)

Record lookup(Phone*);
Record lookup(Phone* const);  // 重复声明 redeclares Record lookup(Phone*)
```
如果形参是某种类型的指针或引用，可通过区分指向的是常量对象还是非常量对象来实现函数重载，此时const是底层的，下面是四个不同的函数：

```cpp
Record lookup(Account&);       // function that takes a reference to Account
Record lookup(const Account&); // new function that takes a const reference

Record lookup(Account*);       // new function, takes a pointer to Account
Record lookup(const Account*); // new function, takes a pointer to const
```

### const_cast与函数重载

```cpp
const string &shorterString(const string &s1, const string &s2){
    return s1.size() <= s2.size() ? s1 : s2;
}
```
上面的函数可通过const_cast将函数的入参和返回值改变为普通引用：
```cpp
string &shorterString(string &s1, string &s2){
    auto &r = shorterString(const_cast<const string&>(s1),
                            const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

### 作用域

```cpp
string read();
void print(const string &);
void print(double);   // overloads the print function
void fooBar(int ival){
    bool read = false; // new scope: hides the outer declaration of read
    string s = read(); // error: read is a bool variable, not a function
    // 通常不这样定义，为了测试
    void print(int);  // new scope: hides previous instances of print
    print("Value: "); // error: print(const string &) is hidden
    print(ival);      // ok: print(int) is visible
    print(3.14);      // ok: calls print(int); print(double) is hidden
}
```

## 特殊特性

Features for Specialized Uses

### 默认实参

Default Arguments

```cpp
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');

// 函数调用
string window;
window = screen();  // equivalent to screen(24,80,' ')
window = screen(66);// equivalent to screen(66,80,' ')
window = screen(66, 256);      // screen(66,256,' ')
window = screen(66, 256, '#'); // screen(66,256,'#')

window = screen(, , '?'); // error: can omit only trailing arguments
window = screen('?');     // calls screen('?',80,' ')
```

默认实参声明Default Argument Declarations

```cpp
string screen(sz, sz, char = ' ');
string screen(sz, sz, char = '*'); // error: redeclaration

string screen(sz = 24, sz = 80, char);  // ok: adds default arguments
```

默认实参初始化Default Argument Initializers

```cpp
// wd, def, ht 必须声明在函数之外
sz wd = 80;

char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);

string window = screen(); // calls screen(ht(), 80, ' ')

void f2(){
    def =   '*';   // 默认值被改变
    sz wd = 100; // 隐藏了外层定义的wd，但没有改变默认值 hides the outer definition of wd but does not change the default
    window = screen(); // calls screen(ht(), 80, '*')
}
```

### 内联函数和constexpr函数

1. Inline Functions

   调用函数一般比等价表达式要慢些，在大多数机器上调用函数时，调用前要先保存到寄存器，返回时恢复。内联函数可避免函数调用的开销(inline Functions Avoid Function Call Overhead)，在调用节点上展开。定义：加inline：

```cpp
inline const string &shorterString(const string &s1, const string &s2){
        return s1.size() <= s2.size() ? s1 : s2;
}
```
内联说明只是向编译器发出一个请求，编译器可以忽略(The inline specification is only a request to the compiler. The compiler may choose to ignore this request)。

2. constexpr Functions：是指能用于常量表达式的函数，constexpr函数返回和形参类型都得是字面类型，且函数中必须只有一条return语句

```cpp
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();  // ok: foo is a constant expression

// 允许constexpr函数的返回值并非一个常量
// 如果arg是constant expression 则 scale(arg)也是
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

// 当scale的实参是常量时，返回的是常量表达式；
int arr[scale(2)]; // ok: scale(2) is a constant expression
int i = 2;         // i is not a constant expression
// 当i是非常量时，返回的也是非常量，如果此时需要的是常量，编译器则提示错误
int a2[scale(i)];  // error: scale(i) is not a constant expression
```

## 函数指针

Pointers to Functions：函数指针指向的是函数而非对象，函数指针由返回类型和形参决定，和函数名无关：

```cpp
bool lengthCompare(const string &, const string &);

// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &);  // uninitialized
// 错误：声明一个pf函数，返回为bool*
bool *pf (const string &, const string &);
```

使用：

```cpp
pf = lengthCompare;  // pf now points to the function named lengthCompare
pf = &lengthCompare; // equivalent assignment: address-of operator is optional

bool b1 = pf("hello", "goodbye");    // calls lengthCompare
bool b2 = (*pf)("hello", "goodbye"); // equivalent call
bool b3 = lengthCompare("hello", "goodbye"); // equivalent call

string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0;              // ok: pf points to no function
pf = sumLength;      // error: return type differs
pf = cstringCompare; // error: parameter types differ
pf = lengthCompare;  // ok:要函数和指针类型精确匹配 function and pointer types match exactly
```

重载：指针类型必须和重载函数中的某一个精确匹配

```cpp
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff;  // pf1 points to ff(unsigned)

void (*pf2)(int) = ff;    // error: no ff with a matching parameter list
double (*pf3)(int*) = ff; // error: return type of ff and pf3 don't match
```

不能定义函数指针形参(Pointer Parameters)，但是形参可以是指向函数的指针，看起来是形参，实际上是当成指针在用：

```cpp
// 第三个会自动转换成指向函数的指针，third parameter is a function type and is automatically treated as a pointer to function
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));

// 等价显式声明 equivalent declaration: explicitly define the parameter as a pointer to function
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));

// 使用
useBigger(s1, s2, lengthCompare);
```

使用decltype简化函数指针：

```cpp
// Func、Func2是函数类型 Func and Func2 have function type
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; // equivalent type

// FuncP、FuncP2是函数指针类型 FuncP and FuncP2 have pointer to function type
typedef bool(*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2;  // equivalent type
```

```cpp
// equivalent declarations of useBigger using type aliases
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```

返回指向函数的指针(a Pointer to Function)：通过类型别名返回函数指针

```cpp
using F = int(int*, int);     // F is a function type, not a pointer
using PF = int(*)(int*, int); // PF is a pointer type
```

```cpp
PF f1(int); // ok: PF is a pointer to function; f1 returns a pointer to function
F f1(int);  // error: F is a function type; f1 can't return a function
F *f1(int); // ok: explicitly specify that the return type is a pointer to function
```

使用其他方式返回：

```cpp
 int (*f1(int))(int*, int);

// 尾置返回类型
auto f1(int) -> int (*)(int*, int);
```
