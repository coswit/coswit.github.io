

类的基本思想是数据抽象(data abstraction)和封装(encapsulation)，是一种依赖于接口和实现分离的编程技术。

### 抽象数据类型(Abstract Data Types)定义

Sales_item.h
```cpp
#ifndef SALESITEM_H
// we're here only if SALESITEM_H has not yet been defined 
#define SALESITEM_H

// Definition of Sales_item class and related functions goes here
#include <iostream>
#include <string>

class Sales_item {

    friend std::istream &operator>>(std::istream &, Sales_item &);

    friend std::ostream &operator<<(std::ostream &, const Sales_item &);

    friend bool operator<(const Sales_item &, const Sales_item &);

    friend bool
    operator==(const Sales_item &, const Sales_item &);

public:
    
    // default constructor needed to initialize members of built-in type
    Sales_item() = default;

    Sales_item(const std::string &book) : bookNo(book) {}

    Sales_item(std::istream &is) { is >> *this; }

public:
    // operations on Sales_item objects
    // member binary operator: left-hand operand bound to implicit this pointer
    Sales_item &operator+=(const Sales_item &);

    // operations on Sales_item objects
    std::string isbn() const { return bookNo; }

    double avg_price() const;
// private members as before
private:
    std::string bookNo;      // implicitly initialized to the empty string
    unsigned units_sold = 0; // explicitly initialized
    double revenue = 0.0;
};

inline
bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) { return lhs.isbn() == rhs.isbn(); }

// nonmember binary operator: must declare a parameter for each operand
Sales_item operator+(const Sales_item &, const Sales_item &);

inline bool
operator==(const Sales_item &lhs, const Sales_item &rhs) {
    // must be made a friend of Sales_item
    return lhs.units_sold == rhs.units_sold &&
           lhs.revenue == rhs.revenue &&
           lhs.isbn() == rhs.isbn();
}

inline bool
operator!=(const Sales_item &lhs, const Sales_item &rhs) {
    return !(lhs == rhs); // != defined in terms of operator==
}

// assumes that both objects refer to the same ISBN
Sales_item &Sales_item::operator+=(const Sales_item &rhs) {
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}

// assumes that both objects refer to the same ISBN
Sales_item
operator+(const Sales_item &lhs, const Sales_item &rhs) {
    Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return
    ret += rhs;           // add in the contents of (|rhs|) 
    return ret;           // return (|ret|) by value
}

std::istream &
operator>>(std::istream &in, Sales_item &s) {
    double price;
    in >> s.bookNo >> s.units_sold >> price;
    // check that the inputs succeeded
    if (in)
        s.revenue = s.units_sold * price;
    else
        s = Sales_item();  // input failed: reset object to default state
    return in;
}

std::ostream &
operator<<(std::ostream &out, const Sales_item &s) {
    out << s.isbn() << " " << s.units_sold << " "
        << s.revenue << " " << s.avg_price();
    return out;
}

double Sales_item::avg_price() const {
    if (units_sold)
        return revenue / units_sold;
    else
        return 0;
}

#endif
```

`Sales_data.h`定义：

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <string>
#include <iostream>

class Sales_data {
    friend Sales_data add(const Sales_data &, const Sales_data &);

    friend std::ostream &print(std::ostream &, const Sales_data &);

    friend std::istream &read(std::istream &, Sales_data &);

public:
    // constructors
    Sales_data() = default;
    Sales_data(const std::string &s) : bookNo(s) {};
    Sales_data(const std::string &s, unsigned n, double p) :
            bookNo(s), units_sold(n), revenue(p * n) {};
    Sales_data(std::istream &);

    // 见下文
    std::string isbn() const { return bookNo; }

    Sales_data &combine(const Sales_data &);

    double avg_price() const;

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

// 非成员接口函数nonmember Sales_data interface functions
Sales_data add(const Sales_data &, const Sales_data &);
std::ostream &print(std::ostream &, const Sales_data &);
std::istream &read(std::istream &, Sales_data &);

inline
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
    return lhs.isbn() < rhs.isbn();
}

#endif
```
`Sales_data.cc`定义：

```cpp
#include <iostream>
#include "Sales_data.h"

using std::istream; using std::ostream;

Sales_data::Sales_data(std::istream &is) {
    // read will read a transaction from is into this object
    read(is, *this);
}

double Sales_data::avg_price() const {
    if (units_sold)
        return revenue / units_sold;
    else
        return 0;
}

// 返回this对象的函数 add the value of the given Sales_data into this object
Sales_data &
Sales_data::combine(const Sales_data &rhs) {
    units_sold += rhs.units_sold; // add the members of rhs into
    revenue += rhs.revenue;       // the members of ``this'' object
    return *this; // return the object on which the function was called
}

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
    Sales_data sum = lhs;  // copy data members from lhs into sum
    sum.combine(rhs);      // add data members from rhs into sum
    return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
istream &
read(istream &is, Sales_data &item) {
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

ostream &
print(ostream &os, const Sales_data &item) {
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
```

使用：

```cpp
Sales_data total;         // variable to hold the running sum
if (read(cin, total))  {  // read the first transaction
    Sales_data trans;     // variable to hold data for the next transaction
    while(read(cin, trans)) {      //  read the remaining transactions
        if (total.isbn() == trans.isbn())   // check the isbns
            total.combine(trans);  // update the running total
        else {
            print(cout, total) << endl;  // print the results
            total = trans;               // process the next book
        }
    }
    print(cout, total) << endl;          // print the last transaction
} else {                                 // there was no input
    cerr << "No data?!" << endl;         // notify the user
}
```

#### 常量成员函数(const member function)

`const`作用是修改隐式this指针的类型，默认情况下，this是指向类对象的非常量版本的常量指针(`Sales_data *const`)，不能把this绑定到一个常量对象上，也就是不能在一个常量对象上调用普通的成员函数。应该把this声明成(`const Sales_data *const`),因为调用成员函数没有改变this所指向的对象，同时有助于提高函数的灵活性。

```cpp
std::string isbn() const { return bookNo; }

// 使用
total.isbn()
```

成员函数调用时，隐式地通过this指向调用该函数的对象的成员，实际调用过程：

```cpp
Sales_data::isbn(&total)
```

伪代码，说明隐式this指针如何使用的：

```cpp
// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }
```
####  类相关的非成员函数(Nonmember Class-Related Functions)

这些函数从操作上来说属于类的组成部分，但实际上并不属于类本身

```cpp
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}

Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;  // copy data members from lhs into sum
    sum.combine(rhs);      // add data members from rhs into sum
    return sum;
}
```

#### 构造函数(Constructors)

类通过构造函数定义了它的对象的初始化方式：

```cpp
struct Sales_data {
    // constructors added
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
};
```

类外部定义的构造函数：

```cpp
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this); // 从is中读取信息存入this对象中
}
```

#### Copy、赋值(Assignment) 和析构(Destruction) 

```
total = trans;               // process the next book
```

```cpp
// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
```

### 访问控制与封装

Access Control and Encapsulation：使用访问说明符(access specifiers)，如public、private

关键字class与struct：class默认private，struct默认public

#### Friends
类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

```cpp
class Sales_data {
// friend declarations for nonmember Sales_data operations added
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
// other members and access specifiers as before
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);
private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
// declarations for nonmember parts of the Sales_data interface
Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
```

### 其他特性

#### 定义类型成员(Type Member)

通过定义成员`pos`来隐藏实现细节，定义在类内部的函数自动是inline的，

```cpp
class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor
    // cursor initialized to 0 by its in-class initializer
    Screen(pos ht, pos wd, char c): height(ht), width(wd),
                                    contents(ht * wd, c) { }
    char get() const             
        { return contents[cursor]; }       // 隐式inline implicitly inline
    inline char get(pos ht, pos wd) const; // 显式 explicitly inline
    Screen &move(pos r, pos c);      // can be made inline later
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```
也可以通过使用别名来实现：
```cpp
class Screen {
public:
    using pos = std::string::size_type; 
};
```

在类外部通过inline来定义：

```cpp
inline Screen &Screen::move(pos r, pos c)
{
    pos row = r * width; // compute the row location
    cursor = row + c ;   // move cursor to the column within that row
    return *this;        // return this object as an lvalue
}

// 在类内部声明为inline
char Screen::get(pos r, pos c) const
{
    pos row = r * width;      // compute row location
    return contents[row + c]; // return character at the given column
}
```

可变数据成员(mutable data member)，通过`mutable`关键字改变：

```cpp
class Screen {
public:
    void some_member() const;
private:
    mutable size_t access_ctr; // may change even in a const object
};
void Screen::some_member() const
{
    ++access_ctr;    // keep a count of the calls to any member function
}
```

#### 返回`*this`成员函数

 Functions That Return `*this`

```cpp
class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
};
inline Screen &Screen::set(char c)
{
    contents[cursor] = c; // set the new value at the current cursor location
    return *this;         // return this object as an lvalue
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
    contents[r*width + col] = ch;  // set specified location to given value
    return *this;                  // return this object as an lvalue
}
```

```cpp
// move the cursor to a given position, and set that character
myScreen.move(4,0).set('#');
// 等价于
myScreen.move(4,0);
myScreen.set('#');
```

如果move返回的是Screen而非Screen&，上述调用则完全不同：

```cpp
Screen temp = myScreen.move(4,0);  // 对返回值进行copy  the return value would be copied
temp.set('#'); //不会改变myScreen的contents值 the contents inside myScreen would be unchanged
```

Returning *this from a const Member Function，函数重载

```cpp
class Screen {
public:
    // 函数重载 display overloaded on whether the object is const or not
    Screen &display(std::ostream &os)
                  { do_display(os); return *this; }
    const Screen &display(std::ostream &os) const
                  { do_display(os); return *this; }
private:
     // function to do the work of displaying a Screen
     void do_display(std::ostream &os) const {os << contents;}
};
```

```cpp
Screen myScreen(5,3);
const Screen blank(5, 3);
myScreen.set('#').display(cout);   // calls non const version
blank.display(cout);               // calls const version
```

#### Class Types

每个类都定义了唯一类型，即使成员完全一样，两个类也是不同的：

```cpp
struct First {
    int memi;
    int getMem();
};
struct Second {
    int memi;
    int getMem();
};
First obj1;
Second obj2 = obj1; // error: obj1 and obj2 have different types
```

```cpp
Sales_data item1;       // default-initialized object of type Sales_data
class Sales_data item1; // 等价声明，从c语言继承来
```

类的声明和定义可以分离开来，仅声明而不定义称为**前向声明(forward declaration)**，在声明之后定义之前是一个不完全类型(incompelete type)：

```cpp
class Screen; // declaration of the Screen class
```

####  Friendship Revisited

友元类，友元不具有传递性，每个类负责自己的友元类和友元函数

```cpp
class Screen {
    friend class Window_mgr;
};
```

```cpp
class Window_mgr {
public:
    // location ID for each screen on the window
    using ScreenIndex = std::vector<Screen>::size_type;
    // reset the Screen at the given position to all blanks
    void clear(ScreenIndex);
private:
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
void Window_mgr::clear(ScreenIndex i)
{
    // s is a reference to the Screen we want to clear
    Screen &s = screens[i];
    // reset the contents of that Screen to all blanks
    s.contents = string(s.height * s.width, ' ');
}
```

把一个成员函数声明为友元时(Making A Member Function a Friend)，必须指出该成员函数属于哪个类：

```cpp
class Screen {
    // Window_mgr::clear must have been declared before class Screen
    friend void Window_mgr::clear(ScreenIndex);
};
```

友元与重载，不同函数需要分别声明友元，函数名相同不一定是相同函数

```cpp
// overloaded storeOn functions
extern std::ostream& storeOn(std::ostream &, Screen &);
extern BitMap& storeOn(BitMap &, Screen &);
class Screen {
    // ostream version of storeOn may access the private parts of Screen objects
    friend std::ostream& storeOn(std::ostream &, Screen &);
};
```

友元声明作用域，需要先声明

```cpp
struct X {
    friend void f() { /* friend function can be defined in the class body   */ }
    X() { f(); } // error: no declaration for f
    void g();
    void h();
};
void X::g() { return f(); } // error: f hasn't been declared
void f();                   // declares the function defined inside X
void X::h() { return f(); } // ok: declaration for f is now in scope
```

### 作用域

每个类都有自己的作用域，在类的作用域外，函数成员只能由对象、引用、指针使用成员访问运算符来访问；对于类类型成员则使用作用域运算符访问。

```cpp
Screen::pos ht = 24, wd = 80; // use the pos type defined by Screen
Screen scr(ht, wd, ' ');
Screen *p = &scr;
char c = scr.get(); // fetches the get member from the object scr
c = p->get();       // fetches the get member from the object to which p points 
```

####  Name Lookup与类作用域

**name lookup**的过程：

- 先在块中寻找名称出现之前的声明语句(look for a declaration of the name in the block in which the name was used)
- 如果没找到，则查找外层作用域(the enclosing scope(s))
- 还没找到则报错

类内部成员函数:

- 编译成员的声明
- 类全部可见后才编译函数体

如果函数使用了外层域的某个名称，则该名称代表了一种类型，之后不能重新定义该名称：

```c
typedef double Money;
class Account {
public:
    Money balance() { return bal; }  // uses Money from the outer scope
private:
    typedef double Money; // error: cannot redefine Money
    Money bal;
};
```

作用域：

```cpp
int height;
class Screen {
public:
    typedef std::string::size_type pos;
    void dummy_fcn(pos height) {
        // 用的函数的
        cursor = width * height;
        // 用的成员变量
        cursor = width * Screen::height;
        cursor = width * this ->height;
        // 用的全局变量
        cursor = width * ::height;
    }
private:
    pos cursor = 0;
    pos height = 0, width = 0;
};
```

解析：

```cpp
int height;
class Screen {
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0;  // hides the declaration of height in the outer scope
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
    // var: refers to the parameter
    // height: refers to the class member
    // verify: refers to the global function
    height = verify(var);
}
```

### 构造函数

#### 初始值列表(Initializer List)

```c
string foo = "Hello World!"; // define and initialize
string bar;                  // default initialized to the empty string
bar = "Hello World!";        // assign a new value to bar
```

如果成员是const或者引用，必须初始化；当成员是某种类类型且该类没有定义默认构造函数时，也必须将该成员初始化

```cpp
class ConstRef {
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};

ConstRef::ConstRef(int ii)
{
    i = ii; // ok
    ci = ii; //error，不能赋值
    ri = ii; //err, ri必须初始化
}

// ok: explicitly initialize reference and const members
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {  }
```

初始化不限制顺序，但如果一个成员用另一个成员初始化，则有影响：

```cpp
class X {
    int i;
    int j;
public:
    // undefined:  i is initialized before  j
    X(int val): j(val), i(j) { }
};

X(int val): i(val), j(val) { }
```

Default Arguments

```cpp
class Sales_data {
public:
    // defines the default constructor as well as one that takes a string argument
    Sales_data(std::string s = ""): bookNo(s) { }
    
    // remaining constructors unchanged
    Sales_data(std::string s, unsigned cnt, double rev):
          bookNo(s), units_sold(cnt), revenue(rev*cnt) { }
          
    Sales_data(std::istream &is) { read(is, *this); }
};
```

#### 委托构造函数

Delegating Constructors，一个构造函数通过所属类的其他构造函数进行初始化

```cpp
class Sales_data {
public:
    // nondelegating constructor initializes members from corresponding arguments
    Sales_data(std::string s, unsigned cnt, double price) :
            bookNo(s), units_sold(cnt), revenue(cnt * price) {}

    // 其于都使用委托
    Sales_data() : Sales_data("", 0, 0) {}
    Sales_data(std::string s) : Sales_data(s, 0, 0) {}
    Sales_data(std::istream &is) : Sales_data() { read(is, *this); }
};
```

类的某些成员缺少了默认构造函数：

```cpp
class NoDefault {
public:
    NoDefault(const std::string &);
};

struct A {
    NoDefault my_mem;
};
A a;       //  error: 不能为a合成构造函数 cannot synthesize a constructor for A
struct B {
    B() {} //  error: no initializer for b_member
    NoDefault b_member;
};
```

使用默认构造函数：

```cpp
Sales_data obj();   // ok: 定义了个函数
Sales_data obj2;  // ok: 默认初始化对象
```

#### 隐式类型转换

Implicit Class-Type Conversions，如果构造函数只有一个实参，实际上定义了转换为此种类型的隐式转换机制，这种构造函数称为**转换构造函数**(converting constructor)

```cpp
class Sales_data {
public:
    Sales_data(const std::string &s) : bookNo(s) {};
    Sales_data(std::istream &);
    Sales_data &combine(const Sales_data &);

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

string null_book = "9-999-99999-9";
// item为Sales_data，编译器用给定的string自动创建了一个Sales_data对象
item.combine(null_book);
```

编译器只会自动执行一次转换：

```cpp
// error: 需要执行两次转换，requires two user-defined conversions:
//    (1) convert "9-999-99999-9" to string
//    (2) convert that (temporary) string to Sales_data
item.combine("9-999-99999-9");

// ok: explicit conversion to string, implicit conversion to Sales_data
item.combine(string("9-999-99999-9"));
// ok: implicit conversion to string, explicit conversion to Sales_data
item.combine(Sales_data("9-999-99999-9"));
```


可通过`explicit`抑制隐式转换，且只对单参构造函数有效：

```cpp
class Sales_data {
public:
    Sales_data() = default;

    Sales_data(const std::string &s, unsigned n, double p) :
            bookNo(s), units_sold(n), revenue(p * n) {}

    explicit Sales_data(const std::string &s) : bookNo(s) {}

    explicit Sales_data(std::istream &);
};

item.combine(null_book);  // error: string constructor is explicit
item.combine(cin);        // error: istream constructor is explicit
```

explicit只允许出现在类内的构造函数：

```cpp
// error: explicit allowed only on a constructor declaration in a class header
explicit Sales_data::Sales_data(istream& is)
{
    read(is, *this);
}
```

explicit只能用于直接初始化：

```cpp
Sales_data item1 (null_book);  // ok: direct initialization
// error: cannot use the copy form of initialization with an explicit constructor
Sales_data item2 = null_book;
```

通过显式转换来使用(Explicitly Using Constructors for Conversions)：

```cpp
// ok: the argument is an explicitly constructed Sales_data object
item.combine(Sales_data(null_book));
// ok: static_cast can use an explicit constructor
item.combine(static_cast<Sales_data>(cin));
```

#### 聚合类

 Aggregate Classes：1. 所有成员(data members)都是pulic  2. 没有定义构造函数 3.没有类内初始值(in-class initializers) 4. 没有基类和virtual函数。

如：

```cpp
struct Data {
    int ival;
    string s;
};
```
可通过这种方式来初始化聚类：
```cpp
// val1.ival = 0; val1.s = string("Anna")
Data val1 = { 0, "Anna" };

// error: can't use "Anna" to initialize ival, or 1024 to initialize s
Data val2 = { "Anna", 1024 };
```

####  字面常量类(Literal Classes)
constexpr构造函数：

```cpp
class Debug {
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) { }
    constexpr Debug(bool h, bool i, bool o):
                                    hw(h), io(i), other(o) { }
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw;    // hardware errors other than IO errors
    bool io;    // IO errors
    bool other; // other errors
};
```
使用：
```cpp
constexpr Debug io_sub(false, true, false);  // debugging IO
if (io_sub.any())  // equivalent to if(true)
    cerr << "print appropriate error messages" << endl;
constexpr Debug prod(false); // no debugging during production
if (prod.any())    // equivalent to if(false)
    cerr << "print an error message" << endl;
```

### 静态成员

static Class Members，通过添加static关键字，使类的成员和类相关，而不是和对象相关。

```cpp
class Account {
public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

使用，可以使用作用域运算符(the scope operator)直接访问：

```cpp
double r;
r = Account::rate(); 
```

也可以使用类的对象、指针、引用来访问：
```cpp
Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function
r = ac1.rate();      // through an Account object or reference
r = ac2->rate();     // through a pointer to an Account object
```

在类的外部定义静态函数时，不能重复static字段，static只能在内部：

```cpp
void Account::rate(double newRate)
{
    interestRate = newRate;
}
```

静态成员的类内初始化(In-Class Initialization of static Data Members)，通常情况下，类的静态成员初始化不应该在内部初始化，但可以为静态成员提供const类型的类内初始值，要求成员是constexpr字面类型，如果类的内部提供了一个初始值，则成员定义不能再指定一个初始值了。

即使一个常量静态成员在类内初始化了，通常情况下也应该在类的外部定义一下该成员。

```cpp
class Account {
public:
    static double rate() { return interestRate; }
    static void rate(double);
private:
    static constexpr int period = 30;// period is a constant expression
    static double interestRate;
    double daily_tbl[period];
};

// definition of a static member with no initializer
constexpr int Account::period; // initializer provided in the class definition
```

静态成员独立于对象，在某些非法场合，静态成员可以正常使用，如：静态成员可以是不完全类型(incompelete type)：

```cpp
class Bar {
public:
    // ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2;       // ok: pointer member can have incomplete type
    Bar mem3;        // error: data members must have complete type
};
```
可以静态成员作为默认实参：
```cpp
class Screen { 
public:
    // bkground refers to the static member
    // declared later in the class definition
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```

