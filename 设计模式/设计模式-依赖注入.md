###  Part 1: A Practical Approach
Many famous libraries that you must have come across in Android development such as **ButterKnife, Dagger2, Room, GreenDao, PlaceHolderView** etc, use annotation processing.

#### The motivation for writing this tutorial:
There are a couple of good annotation processing tutorials and examples available on the internet but it was really difficult for me to search any reference that provided a complete solution, apart from the setup process. So, I decided to write this tutorial that aims to cover the following:

1. Basics of annotation processing.
2. Create a complete Android library similar to ButterKnife.
3. Provide an introduction to JavaPoet.
4. Explains the essentials for the created library.

#### Introduction
Annotation processing has become one of the most important language features in the modern Java programming. Java supports annotation processing from the release of Java 5 but its full potential has been realized in the recent years. Annotation processing in simple words is used to generate files during compilation.

`Limitation`: Annotation processing can only be used to generate new files and not to modify old ones.

`Note:` Annotation processing is not only used for writing .java files but all kinds of files. 
Example - metadata text files.

> The real beauty is not in the fancy outer looks but in the simple within.

Let’s explore if it’s a fancy way to write code or it really does solve some problems that we encounter in software development.

#### Case Study :
**Remove the codes that use Java Reflection APIs and make it safe from runtime exceptions**

Reflection is a process in which we read a class and it’s member properties during runtime and try to modify these properties. This process though helps ous in creating a generic or implementation independent program but is also prone to lots of exceptions as we do not know the exact condition at the runtime. Class scanning and modification by reflection is a slow process and also an ugly way to isolate the code.

`Example`: Suppose we want to map a view object from XML to a Java class. Then by using reflection, we can do something similar to this.

- Define an annotation BindView for mapping.
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface BindView {
    int value();
} 
```
- Place BindView annotation on a View class variable with the view's id.
```java
public class MainActivity extends AppCompatActivity {
    ...
    @BindView(R.id.txtView)
    TextView txtView;
    ...
}
```

- Create a class that does the assignment of the TextView object defined in the XML with the id tv_name to the variable tvName.
```java
public class ViewBinder {
    /*
     * annotations for activity class
     * @param target is the activity with annotations
     */
    public static void bind(final Activity target){
        bindViews(target, target.getClass().getDeclaredFields(),
    }

    /*
     * initiate the view for the annotated public fields
     * @param obj is any class instance with annotations
     * @param fields list of methods in the class with annotation
     * @param rootView is the inflated view from the XML
     */
    private static void bindViews(final Object obj, Field[] fields, View rootView){
        for(final Field field : fields) {
            Annotation annotation = field.getAnnotation(BindView.class);
            if (annotation != null) {
                BindView bindView = (BindView) annotation;
                int id = bindView.value();
                View view = rootView.findViewById(id);
                try {
                    field.setAccessible(true);
                    field.set(obj, view);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```
- Send the Activity instance to the ViewBinder .
```java
public class MainActivity extends AppCompatActivity {

    @BindView(R.id.txtView)
    private TextView txtView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ViewBinder.bind(this);
        txtView.setText("Testing");
    }
    ...
}
```
**This works fine but the limitation that we just talked about reflection make it undesirable.**

#### So, how can we improve upon it?
This is an interesting question and the answer to this is the motivation for exploring the powerful APIs of annotation processing.

1. We have to eliminate the runtime scan of the MainActivity class and replace it with method calls.
2. We would not want to write those methods for every Activity and want them to get generated automatically.
3. We would want to eliminate any runtime exceptions and like to move such checks during compile time itself.

These three conditions can be satisfied with the use of annotation processing.

**So, are you excited to explore how to do this?**

**It is simpler than you might have heard. So, let's break the taboo and understand it.**

> The biggest hurdle in reaching the other side of the tunnel is not the task that is difficult but the lack of efforts. We are limited by the fear developed through the mouth of others.
#### How does the annotation processing work?
The annotation processing takes place in many compilation cycles. In each cycle, the compiler while reading a java source file finds the annotations registered for processing and calls the corresponding annotation processor. This cycle continues with the generation of any file or terminates if no file is generated in that cycle.


------

### Part 2: The Project Structure

We will develop a project that will be similar to the `ButterKnife` but very minimalistic. It will be written in the form of an Android library.

Following are the list of features that we will develop:

- **@BindView** to map XML view to the variable using the view's id.
- **@OnClick** to map a method to a view's OnClickListerner
- Generate binding classes to deal with mappings and casts


#### Example client code:
```java
public class MainActivity extends AppCompatActivity {

    @BindView(R.id.tv_content)
    TextView tvContent;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Binding.bind(this);
    }

    @OnClick(R.id.bt_1)
    void bt1Click(View v) {
        tvContent.setText("Button 1 Clicked");
    }

    @OnClick(R.id.bt_2)
    void bt2Click(View v) {
        tvContent.setText("Button 2 Clicked");
    }
}
```
The source code for this tutorial can be found here

[https://github.com/MindorksOpenSource/annotation-processing-example](https://github.com/MindorksOpenSource/annotation-processing-example)

#### There are four modules in this project:
- app : This is the Android app project.
- binder: This module provides a class that maps a given activity's annotated view objects and click listener methods to the XML views.
- binder-annotations: This module defines the annotations to facilitate the mapping of the views and click listeners.
- binder-compiler: This module defines the processor that generates the classes to help the above mappings.

#### We will first define annotations
Annotations are the metadata that can be added to a Java source file. They help in reading the properties of a class and its members while processing.

The annotations will be used in the Android application as well as the Processor, so we will create a Java library named **binder-annotations**.

> Android Studio -> file -> new module -> java library

##### We will define three annotations:

1. BindView: It will map a view reference to its XML definition. Example: TextView with id tv_content will be mapped to a variable tvContent.
```java
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.FIELD)
public @interface BindView {
    @IdRes int value();
}
```
2. OnClick: It will map a method which will be called when a view with the provided id is clicked.
```java
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
public @interface OnClick {
    @IdRes int value();
}
```
3. Keep: This is an interesting annotation. We have to create this annotation to prevent the proguard to obfuscate our generated classes. You will understand the importance of this annotation later in the tutorial.
```java
/**
 * It will keep any class after proguard minify
 */
@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
public @interface Keep {
}
```
##### In this definition there are three things to understand:

> Note: We define an annotation using the @interface keyword.

###### RetentionPolicy: 
It defines the level of presence of the annotation in the code. Here SOURCE implies that the annotation will be present in the Java source code but will be removed when the code is compiled. CLASS policy means that the annotations will be preserved in the compiled bytecode in addition to the source code.
###### Target:
It defines the elements on which the annotation can be used. FIELD means that the annotations can be used on a member variable. METHOD means that it can be used on any class methods and TYPE means that is can be used on a class.
###### Value: 
It defines the type of primitive value that can be passed through these annotations. Here we can pass an int value to the annotations.

Here you can notice `@IdRes` annotation. This annotation is provided by the **support-annotations library**. We have used this so that the IDE can show the error if any int value other than the resource id corresponding to the view is passed as the annotation's value. To achieve this we have to add the following dependency in the binder-compiler module.

```gradle
compileOnly 'com.android.support:support-annotations:27.1.1'
```

**CompileOnly** allows us to use a library in a module but not make it available when it is distributed. Since all the android application inculde this dependency so we are safe to not ship this dependency will our library distribution.

Now that we have defined our annotations. We will move to the fun part of this tutorial i.e. creating the processor that does the magic.

> Slow but steady wins the race


#### Create Annotation Processor
Annotation processor run in cycles and in parallel to the application compilation. In each cycle, the processor is provided with the information about the application's source code being compiled.

A processor must be registered to the compiler so that it can run while the application is being compiled. We will see how to define such a compiler.

Now, we will create a Java library **binder-compiler** similar to our binder-annotations. In this module we will have to create the directory structure:

**binder-compiler/src/main/resources/META-INF/services**

In the services directory, we will create a file named **javax.annotation.processing.Processor**. This file will list the classes that the compiler will call when it compiles the application's source code while annotation processing.

> **src/main/resources/META-INF/services/javax.annotation.processing.Processor** path is the defined path for Java compiler to look for annotation processors.

#### Annotation Processor Definition
All annotation processor inherit AbstractProcessor which defines the base methods for the processing. We will create a class Processor in this library that inherit AbstractProcessor. We have to override three methods to provide our implementations for the processing.

- **init**: Here we will get Filer, Messager, and Elements.
- **process**: This method is called to process the source code of the application. Here we will define a class and write the Java source code.
- **getSupportedAnnotationTypes**: It lists the annotations that we intend to query while processing the application's Java files.
#### Filer, Messager, Elements:
- **Filer**: It provides the APIs to write the generated source code file.
- **Messager**: It is used to print messages when the compilation is taking place. We send the error messages that may arrises in processing via Messager. Since annotation processor runs in its own separate environment, we can not communicate with the application by any other means.
- **Elements**: It provides the utils methods for filtering the different type of elements in the processor.
```java
public class Processor extends AbstractProcessor {

    private Filer filer;
    private Messager messager;
    private Elements elementUtils;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
        elementUtils = processingEnv.getElementUtils();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // all the magic happens in this block  
        return true;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return new TreeSet<>(Arrays.asList(
                BindView.class.getCanonicalName(),
                OnClick.class.getCanonicalName(),
                Keep.class.getCanonicalName()));
    }
}
```
We need to register this Processor to the **javax.annotation.processing.Processor** file using its complete cannonical name.
> com.mindorks.compiler.lib.Processor

Now before we proceed forward we must understand the Element.

#### Element
Element represents a program element such as package, class, or methods. We work with elements to read its properties while processing. Three important elements that we need for this tutorial are:

- **TypeElement**: It represents a class or interface.
- **VariableElement**: It represents a field.
- **ExecutableElement**: It represents a method.

### Part 3: Generate Java Source Code

Things that annotation processing provides while processing the Java annotated source code:

- **Set<? extends TypeElement>**: It provides a list of annotations as elements that are contained in the Java file being processed.
- **RoundEnvironment**: It provides access to the processing environment with utils to querying elements. Two main functions we will use from this environment are: **processingOver**(A mean to know if its the last round of processing) and **getRootElements**(It provides a list of elements that will get processed. Some of these elements will contain the annotation that we are interested.)

So, we have a set of annotations and a list of elements. Our library will generate a wrapper class that will help to map the views and clicks listeners for an activity.

**It will have the following usage**:

**activity_main.xml** defines a TextView with id `tv_content` and two buttons with id `bt_1` and `bt_2` . Our annotations will map the view and buttons to remove the boilerplate just like ButterKnife.
```java
public class MainActivity extends AppCompatActivity {

    @BindView(R.id.tv_content)
    TextView tvContent;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Binding.bind(this);
    }

    @OnClick(R.id.bt_1)
    void bt1Click(View v) {
        tvContent.setText("Button 1 Clicked");
    }

    @OnClick(R.id.bt_2)
    void bt2Click(View v) {
        tvContent.setText("Button 2 Clicked");
    }
}
```
We will use the **MainActivity** definition to auto generate our wrapper class named **MainActivity$Binding** using annotation processing.

> Note: Any Activity in which we will use our annotations will result in the creation of a wrapper class ending with `$Binding` in its name. 

Example: If we have another activity say ProfileActivity that has @BindView or @OnClick usage then it will result in the creation of the ProfileActivity$Binding Java source code file.

After processing following class will be created.
```java
@Keep
public class MainActivity$Binding {
  public MainActivity$Binding(MainActivity activity) {
    bindViews(activity);
    bindOnClicks(activity);
  }

  private void bindViews(MainActivity activity) {
    activity.tvContent = (TextView)activity.findViewById(2131165322);
  }

  private void bindOnClicks(final MainActivity activity) {
    activity.findViewById(2131165218).setOnClickListener(new View.OnClickListener() {
      public void onClick(View view) {
        activity.bt1Click(view);
      }
    });
    activity.findViewById(2131165219).setOnClickListener(new View.OnClickListener() {
      public void onClick(View view) {
        activity.bt2Click(view);
      }
    });
  }
}
```
Now that we know what we have to generate, let's analyse how to create it using the information that we have at our disposal while processing.

1.  We will first filter out those classes (Type) Elements that either use `@BindView` or `@OnClick` from the list of elements provided by the getRootElements method.
2. We will then iterate over those filtered Elements and then scan through their members and methods to develop the class schema of the wrapper class using `JavaPoet`. In the end, we will write that class into a Java file.

For step 1 we would want to make the search efficient. So, we will create a class ProcessingUtils that will have the filtering method.
```java
public class ProcessingUtils {

    private ProcessingUtils() {
        // not to be instantiated in public
    }

    public static Set<TypeElement> getTypeElementsToProcess(Set<? extends Element> elements,
                                                            Set<? extends Element> supportedAnnotations) {
        Set<TypeElement> typeElements = new HashSet<>();
        for (Element element : elements) {
            if (element instanceof TypeElement) {
                boolean found = false;
                for (Element subElement : element.getEnclosedElements()) {
                    for (AnnotationMirror mirror : subElement.getAnnotationMirrors()) {
                        for (Element annotation : supportedAnnotations) {
                            if (mirror.getAnnotationType().asElement().equals(annotation)) {
                                typeElements.add((TypeElement) element);
                                found = true;
                                break;
                            }
                        }
                        if (found) break;
                    }
                    if (found) break;
                }
            }
        }
        return typeElements;
    }
}
```
#### Here two things we need to understand:
- **element.getEnclosedElements()**: Enclosed elements are the elements that are contained in the given element. In our case the element will be MainActivity (TypeElement) and the Enclosed elemetents will be tvContent, onCreate, bt1Click, bt2Click and other inherited members.
- **subElement.getAnnotationMirrors()**: It will provide all the annotations used on the subElement. Example: @Override for onCreate, @BindView for tvContent and @OnClick for the bt1Click.
So, getTypeElementsToProcess will filter MainActivity as the TypeElement that we need for processing.

Now, we will scan all the filtered elements to create the corresponding wrapper class.

#### Important points:

1.  **Find package of the element**: `elementUtils.getPackageOf(typeElement).getQualifiedName().toString()`(in our case: com.mindorks.annotation.processing.example)
2.  **Get simple name of the element**:` typeElement.getSimpleName().toString() `(in our case MainActivity)
3.  We need **ClassName** to work with the annotation APIs: `ClassName.get(packageName, typeName)` (It will create a ClassName for MainActivity)
4.  We will have to create a ClassName for the Wrapper Class MainActivity$Binding so that we can define its members and methods.

> Note: To facilitate name maintenance and a good coding practice we will create a class named NameStore. It will hold all the class, variables and method names that we need while defining the Binding class.
```java
public final class NameStore {

    private NameStore() {
        // not to be instantiated in public
    }

    public static String getGeneratedClassName(String clsName) {
        return clsName + BindingSuffix.GENERATED_CLASS_SUFFIX;
    }

    public static class Package {
        public static final String ANDROID_VIEW = "android.view";
    }

    public static class Class {
        // Android
        public static final String ANDROID_VIEW = "View";
        public static final String ANDROID_VIEW_ON_CLICK_LISTENER = "OnClickListener";
    }

    public static class Method {
        // Android
        public static final String ANDROID_VIEW_ON_CLICK = "onClick";

        // Binder
        public static final String BIND_VIEWS = "bindViews";
        public static final String BIND_ON_CLICKS = "bindOnClicks";
        public static final String BIND = "bind";
    }

    public static class Variable {
        public static final String ANDROID_ACTIVITY = "activity";
        public static final String ANDROID_VIEW = "view";
    }
}
```
Also, you will find that the **$Binding** suffix is added in the binder-annotations library's **(internal -> BindingSuffix)** class. This is done for two purposes.

- We want the name to be configurable, i.e. we can change it from $Binding to _Binder or anything else.
- It will be used for finding the generated class in both binder and binder-compiler library.

#### JavaPoet Crash Course:
JavaPoet makes it really simple to define a class structure and write it while processing. It creates classes that are very close to a handwritten code. It provides facilities to auto infer the imports as well as beautify the code.

To use JavaPoet we need to add the following dependency into binder-compiler module.

```gradle
dependencies {
    implementation project(':binder-annotations')
    implementation 'com.squareup:javapoet:1.11.1'
}
```
> Note: Using JavaFileObject is very impractical and cumbersome. So, we will not even talk about it.

Basic usage of the JavaPoet that is required for this tutorial (Any advance understanding can be obtained from its GitHub Repo.)

- TypeSpec.Builder: Defines the class schema.
addModifiers (Modifier): Add private, public or protected keyword.
- addAnnotation: Add an annotation to the element. Example: @Override on methods or @Keep on class in our case.
- TypeSpec.Builder -> addMethod: Add methods to the class. Example: constructor or other methods.
- MethodSpec -> addParameter: Add parameter type and its name for the method. Example: In our case, we want to pass MainActivity type with variable name activity to the method.
- MethodSpec -> addStatement: It will add the code blocks inside a method. In this method we 1st define the placeholders of the statement and then pass the paramenters to map those placeholders. Example: addStatement("$N($N)", "bindViews", "activity") (this will generate code bindViews(activity)). PlaceHolders: $N -> names, $T -> type(ClassName), $L -> literals(long etc.).
> Rest of the things can be easily understood with reference to this basic introduction to the JavaPoet. I leave rest up to you to figure out. This is how I learned.
#### Final step: write the java source code.
It is really simple to write the defined class schema with the JavaPoet.
```java
// write the defines class to a java file
try {
    JavaFile.builder(packageName,
            classBuilder.build())
            .build()
            .writeTo(filer);
} catch (IOException e) {
    messager.printMessage(Diagnostic.Kind.ERROR, e.toString(), typeElement);
}
```
It will generate the souce code in the folder. `/app/build/generated/source/apt/debug`

In our case: `/app/build/generated/source/apt/debug/com/mindorks/annotation/processing/example/MainActivity$Binding.java`


* * *
### Part 4: Use The Generated Code

We will add the following dependencies in the app's build.gradle for the annotation processing to run.
```gradle
dependencies {
    ...
    //annotation processing
    implementation project(':binder')
    annotationProcessor project(':binder-compiler')
}
```
Now, when we build our app module then we will find MainActivity$Binding class generated in the directory /app/build/generated/source/apt/debug. This class takes MainActivity in the constructor and then maps and casts the TextView as well as assign the OnClickListener to the buttons.

Since we have generated MainActivity$Binding based on the MainActivity's name so, we don't know the exact name of the generated class prior to the generation (MainActivity can be renamed to something else later in the project lifecycle). So, we need to dynamically find the generated class that maps the given activity.

We will define this functionality in our binding library module.
```java
public class Binding {

    public Binding() {
        // not to be instantiated in public
    }

    private static <T extends Activity> void instantiateBinder(T target, String suffix) {
        Class<?> targetClass = target.getClass();
        String className = targetClass.getName();
        try {
            Class<?> bindingClass = targetClass
                    .getClassLoader()
                    .loadClass(className + suffix);
            Constructor<?> classConstructor = bindingClass.getConstructor(targetClass);
            try {
                classConstructor.newInstance(target);
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Unable to invoke " + classConstructor, e);
            } catch (InstantiationException e) {
                throw new RuntimeException("Unable to invoke " + classConstructor, e);
            } catch (InvocationTargetException e) {
                Throwable cause = e.getCause();
                if (cause instanceof RuntimeException) {
                    throw (RuntimeException) cause;
                }
                if (cause instanceof Error) {
                    throw (Error) cause;
                }
                throw new RuntimeException("Unable to create instance.", cause);
            }
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Unable to find Class for " + className + suffix, e);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Unable to find constructor for " + className + suffix, e);
        }
    }

    public static <T extends Activity> void bind(T activity) {
        instantiateBinder(activity, BindingSuffix.GENERATED_CLASS_SUFFIX);
    }
}
```
Here we have used reflection API to create the instance of the MainActivity$Binding. This is the only place we have used the Reflection API. If we had known the name of the class prior to this then we would have used that class directly.

This is a typical example where the class name is based on the class being processed. So, using reflection is not a big issue. This is how ButterKnife works. In many cases, reflection APIs will not be used at all.

Now, we can use our MainActivity with Binding class:
```java
public class MainActivity extends AppCompatActivity {

    @BindView(R.id.tv_content)
    TextView tvContent;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Binding.bind(this);
    }

    @OnClick(R.id.bt_1)
    void bt1Click(View v) {
        tvContent.setText("Button 1 Clicked");
    }

    @OnClick(R.id.bt_2)
    void bt2Click(View v) {
        tvContent.setText("Button 2 Clicked");
    }
}
```
We can now create an Activity and use @BindView and @OnClick and Binding.bind(this) will do the magic.

#### Last thing:
Remember we had created annotation @Keep and used it on the MainActivity$Binding class. Now, it is time to understand its importance.

We are using reflection to instantiate the `MainActivity$Binding` class. If we apply the proguard while generating the signed APK then the class name will be obfuscated. So, Reflection API will not be able to find MainActivity$Binding class. To overcome this issue we have to tell the proguard to not obfuscate the classes that have @Keep annotation.

Also, we would want to add the progurad rule in the library itself so that client desn't have to worry about it.

To do so we need to do two things:

- First: Add progurad rule in the binder library module's proguard-rules.pro file:
```
-keep class com.mindorks.lib.annotations.Keep**
-keep @com.mindorks.lib.annotations.Keep public class *
-keepclassmembers @com.mindorks.lib.annotations.Keep class ** { *;}
```
- Second: Let the gradle know that this progurad rule has to be added in the module that uses it. We will have to add consumerProguardFiles in the build.gradle of the binder library module.
```gradle
android {

    defaultConfig {
        ...
        consumerProguardFiles 'proguard-rules.pro'
    }
}
```
