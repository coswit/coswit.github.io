## SOLID

- Single Responsibility Principle
- Open-Closed Principle
- Liskov Substitution Principle
- Interface Segregation Principle
- Dependency Inversion Principle

### SRP原则

单一职责原则SRP(Single Responsibility Principle)：一个类只负责一项职责。

> [Robert C. Martin](http://blog.cleancoder.com/) : A class should have one, and only one, reason to change.

### OCP原则

开放封闭原则(Open－Close Principle)：对扩展开放，对修改关闭。增加新功能时，应通过扩展现有代码(继承、实现接口)来实现，而不是修改已有的代码。

> Objects or entities should be open for extension but closed for modification.

### LSP原则

里氏代换(the Liskov Substitution Principle)：子类必须能替换父类而不破坏程序的正确性。

反例：

```java
class Rectangle {
    protected int width, height;

    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    public int getArea() { return width * height; }
}


// 它改变了父类设置长宽的行为，这违反了 LSP。
class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width); 
    }

    @Override
    public void setHeight(int height) {
        super.setWidth(height);
        super.setHeight(height);
    }
}

public void testArea(Rectangle r) {
    r.setWidth(5);
    r.setHeight(4);
    assert r.getArea() == 20; 
}
```

### ISP

接口分离原则(the Interface Segregation Principle)：接口要小而专，不要大而全，不应该强迫客户端去实现不需要的接口。

> A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.


### DIP

依赖倒置原则(the Dependency Inversion Principle DIP)：

1. 高层模块不应该依赖于低层模块。二者都应该依赖于抽象。
2. 抽象不应该依赖于细节。细节应该依赖于抽象。

> Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.

核心思想：要面向接口编程，而不是面向实现；通过抽象(接口或抽象类)来解耦模块之间的依赖关系。

## CARP

合成复用原则(Composition/Aggregate Reuse Principle)：优先使用代码组合或聚合(has-a关系)，而不是继承(is a关系)来实现代码复用。


## Demeter法则

迪米特法则(Law of Demeter)：最少知识原则， 一个对象应尽可能减少对其他对象的了解。

​	如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。
​	迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。
​	在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。